import * as anchor from "@coral-xyz/anchor";
import { type Program, AnchorError, BN } from "@coral-xyz/anchor";
import {
  Keypair,
  PublicKey,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  createMint,
  createAccount,
  mintTo,
  getAccount,
} from "@solana/spl-token";
import { expect } from "chai";

// Import the generated IDL types
// These are generated by `anchor build`
import type { SolanaLotto } from "../target/types/solana_lotto";

// ============================================================================
// CONSTANTS (must match program constants)
// ============================================================================
const LOTTERY_SEED = Buffer.from("lottery");
const TICKET_SEED = Buffer.from("ticket");
const DRAW_SEED = Buffer.from("draw");
const USER_SEED = Buffer.from("user");
const SYNDICATE_SEED = Buffer.from("syndicate");
const UNIFIED_TICKET_SEED = Buffer.from("unified_ticket");
const PRIZE_POOL_USDC_SEED = Buffer.from("prize_pool_usdc");
const HOUSE_FEE_USDC_SEED = Buffer.from("house_fee_usdc");
const INSURANCE_POOL_USDC_SEED = Buffer.from("insurance_pool_usdc");
const SYNDICATE_WARS_SEED = Buffer.from("syndicate_wars");

const TICKET_PRICE = new BN(2_500_000); // $2.50
const SEED_AMOUNT = new BN(500_000_000_000); // $500,000
const SOFT_CAP = new BN(1_750_000_000_000); // $1,750,000
const HARD_CAP = new BN(2_250_000_000_000); // $2,250,000
const JACKPOT_CAP = new BN(1_750_000_000_000);
const DRAW_INTERVAL = new BN(86400); // 24 hours
const HOUSE_FEE_BPS = 2800; // 28%

const USDC_DECIMALS = 6;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Derive all the PDAs needed for the lottery program
 */
function derivePDAs(programId: PublicKey) {
  const [lotteryState, lotteryBump] = PublicKey.findProgramAddressSync(
    [LOTTERY_SEED],
    programId,
  );
  const [prizePoolUsdc] = PublicKey.findProgramAddressSync(
    [PRIZE_POOL_USDC_SEED],
    programId,
  );
  const [houseFeeUsdc] = PublicKey.findProgramAddressSync(
    [HOUSE_FEE_USDC_SEED],
    programId,
  );
  const [insurancePoolUsdc] = PublicKey.findProgramAddressSync(
    [INSURANCE_POOL_USDC_SEED],
    programId,
  );

  return {
    lotteryState,
    lotteryBump,
    prizePoolUsdc,
    houseFeeUsdc,
    insurancePoolUsdc,
  };
}

function deriveTicketPDA(
  programId: PublicKey,
  drawId: number,
  ticketIndex: number,
) {
  return PublicKey.findProgramAddressSync(
    [
      TICKET_SEED,
      new BN(drawId).toArrayLike(Buffer, "le", 8),
      new BN(ticketIndex).toArrayLike(Buffer, "le", 8),
    ],
    programId,
  );
}

function deriveUserStatsPDA(programId: PublicKey, wallet: PublicKey) {
  return PublicKey.findProgramAddressSync(
    [USER_SEED, wallet.toBuffer()],
    programId,
  );
}

function deriveUnifiedTicketPDA(
  programId: PublicKey,
  player: PublicKey,
  drawId: number,
  currentDrawTickets: number,
) {
  return PublicKey.findProgramAddressSync(
    [
      UNIFIED_TICKET_SEED,
      player.toBuffer(),
      new BN(drawId).toArrayLike(Buffer, "le", 8),
      new BN(currentDrawTickets).toArrayLike(Buffer, "le", 8),
    ],
    programId,
  );
}

function deriveDrawResultPDA(programId: PublicKey, drawId: number) {
  return PublicKey.findProgramAddressSync(
    [DRAW_SEED, new BN(drawId).toArrayLike(Buffer, "le", 8)],
    programId,
  );
}

function deriveSyndicatePDA(programId: PublicKey, syndicateId: BN) {
  return PublicKey.findProgramAddressSync(
    [SYNDICATE_SEED, syndicateId.toArrayLike(Buffer, "le", 8)],
    programId,
  );
}

/**
 * Create a USDC mint and return its public key
 */
async function createUsdcMint(
  provider: anchor.AnchorProvider,
  authority: Keypair,
): Promise<PublicKey> {
  return await createMint(
    provider.connection,
    authority,
    authority.publicKey,
    null,
    USDC_DECIMALS,
  );
}

/**
 * Create a USDC token account and mint tokens to it
 */
async function createAndFundUsdcAccount(
  provider: anchor.AnchorProvider,
  mint: PublicKey,
  owner: PublicKey,
  mintAuthority: Keypair,
  amount: number | bigint,
): Promise<PublicKey> {
  const account = await createAccount(
    provider.connection,
    mintAuthority,
    mint,
    owner,
  );
  if (amount > 0) {
    await mintTo(
      provider.connection,
      mintAuthority,
      mint,
      account,
      mintAuthority,
      amount,
    );
  }
  return account;
}

/**
 * Airdrop SOL to a keypair
 */
async function airdrop(
  provider: anchor.AnchorProvider,
  to: PublicKey,
  amount: number = 100 * LAMPORTS_PER_SOL,
) {
  const sig = await provider.connection.requestAirdrop(to, amount);
  await provider.connection.confirmTransaction(sig, "confirmed");
}

/**
 * Wait for a given number of milliseconds
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// ============================================================================
// TEST SUITE: Main Lottery (mazelprotocol)
// ============================================================================
describe("mazelprotocol", () => {
  // Configure the client to use the local cluster
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.mazelprotocol as Program<SolanaLotto>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const programAccounts: any = program.account;
  const programId = program.programId;

  // Test keypairs
  const authority = (provider.wallet as anchor.Wallet).payer;
  let player1: Keypair;
  let player2: Keypair;
  let unauthorizedUser: Keypair;

  // USDC mint and token accounts
  let usdcMint: PublicKey;
  let authorityUsdc: PublicKey;
  let player1Usdc: PublicKey;
  let player2Usdc: PublicKey;
  let destinationUsdc: PublicKey;

  // PDAs
  let pdas: ReturnType<typeof derivePDAs>;

  // Switchboard mock (a random pubkey for the queue — tests that don't touch
  // Switchboard only need a valid Pubkey stored in state)
  const switchboardQueue = Keypair.generate().publicKey;

  // ========================================================================
  // SETUP
  // ========================================================================
  before(async () => {
    player1 = Keypair.generate();
    player2 = Keypair.generate();
    unauthorizedUser = Keypair.generate();

    // Airdrop SOL to all test accounts
    await Promise.all([
      airdrop(provider, player1.publicKey),
      airdrop(provider, player2.publicKey),
      airdrop(provider, unauthorizedUser.publicKey),
    ]);

    // Create USDC mint
    usdcMint = await createUsdcMint(provider, authority);

    // Derive PDAs
    pdas = derivePDAs(programId);

    // Create and fund USDC accounts
    // Authority needs enough for the $500k seed
    const seedAmountLamports = BigInt(SEED_AMOUNT.toString());
    authorityUsdc = await createAndFundUsdcAccount(
      provider,
      usdcMint,
      authority.publicKey,
      authority,
      seedAmountLamports + BigInt(100_000_000_000), // extra for reserve tests
    );

    // Players get $10,000 each for ticket buying
    player1Usdc = await createAndFundUsdcAccount(
      provider,
      usdcMint,
      player1.publicKey,
      authority,
      BigInt(10_000_000_000),
    );
    player2Usdc = await createAndFundUsdcAccount(
      provider,
      usdcMint,
      player2.publicKey,
      authority,
      BigInt(10_000_000_000),
    );

    // Destination for fee withdrawal
    destinationUsdc = await createAndFundUsdcAccount(
      provider,
      usdcMint,
      authority.publicKey,
      authority,
      BigInt(0),
    );
  });

  // ========================================================================
  // 1. INITIALIZATION TESTS
  // ========================================================================
  describe("Initialize", () => {
    it("initializes the lottery successfully", async () => {
      await program.methods
        .initialize({
          ticketPrice: TICKET_PRICE,
          houseFeeBps: HOUSE_FEE_BPS,
          jackpotCap: JACKPOT_CAP,
          seedAmount: SEED_AMOUNT,
          softCap: SOFT_CAP,
          hardCap: HARD_CAP,
          drawInterval: DRAW_INTERVAL,
          switchboardQueue: switchboardQueue,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
          usdcMint: usdcMint,
          prizePoolUsdc: pdas.prizePoolUsdc,
          houseFeeUsdc: pdas.houseFeeUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        })
        .rpc();

      // Fetch and verify the lottery state
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);

      expect(state.authority.toString()).to.equal(
        authority.publicKey.toString(),
      );
      expect(state.ticketPrice.toString()).to.equal(TICKET_PRICE.toString());
      expect(state.houseFeeBps).to.equal(HOUSE_FEE_BPS);
      expect(state.jackpotCap.toString()).to.equal(JACKPOT_CAP.toString());
      expect(state.seedAmount.toString()).to.equal(SEED_AMOUNT.toString());
      expect(state.softCap.toString()).to.equal(SOFT_CAP.toString());
      expect(state.hardCap.toString()).to.equal(HARD_CAP.toString());
      expect(state.drawInterval.toString()).to.equal(DRAW_INTERVAL.toString());
      expect(state.currentDrawId.toString()).to.equal("1");
      expect(state.jackpotBalance.toString()).to.equal("0");
      expect(state.reserveBalance.toString()).to.equal("0");
      expect(state.insuranceBalance.toString()).to.equal("0");
      expect(state.totalTicketsSold.toString()).to.equal("0");
      expect(state.totalPrizesPaid.toString()).to.equal("0");
      expect(state.isPaused).to.be.true;
      expect(state.isFunded).to.be.false;
      expect(state.isDrawInProgress).to.be.false;
      expect(state.isRolldownActive).to.be.false;
      expect(state.pendingAuthority).to.be.null;
    });

    it("fails to initialize a second time (already exists)", async () => {
      try {
        await program.methods
          .initialize({
            ticketPrice: TICKET_PRICE,
            houseFeeBps: HOUSE_FEE_BPS,
            jackpotCap: JACKPOT_CAP,
            seedAmount: SEED_AMOUNT,
            softCap: SOFT_CAP,
            hardCap: HARD_CAP,
            drawInterval: DRAW_INTERVAL,
            switchboardQueue: switchboardQueue,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            usdcMint: usdcMint,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            systemProgram: SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          })
          .rpc();
        expect.fail("Should have thrown an error");
      } catch (err: unknown) {
        // Account already exists — Anchor will throw
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 2. FUND SEED TESTS
  // ========================================================================
  describe("Fund Seed", () => {
    it("fails to buy tickets before funding (lottery is paused)", async () => {
      const [ticketPda] = deriveTicketPDA(programId, 1, 0);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      try {
        await program.methods
          .buyTicket({
            numbers: [1, 2, 3, 4, 5, 6],
            useFreeTicket: false,
          })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — lottery is paused");
      } catch (err: unknown) {
        // Should be Paused error
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("Paused");
        }
      }
    });

    it("fails to fund seed from non-authority", async () => {
      // Create a USDC account for the unauthorized user
      const unAuthUsdc = await createAndFundUsdcAccount(
        provider,
        usdcMint,
        unauthorizedUser.publicKey,
        authority,
        BigInt(SEED_AMOUNT.toString()),
      );

      try {
        await program.methods
          .fundSeed()
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
            authorityUsdc: unAuthUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — not authority");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("funds the seed successfully", async () => {
      const prizePoolBefore = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      expect(Number(prizePoolBefore.amount)).to.equal(0);

      await program.methods
        .fundSeed()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
          authorityUsdc: authorityUsdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();

      // Verify state after funding
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.jackpotBalance.toString()).to.equal(SEED_AMOUNT.toString());
      expect(state.isFunded).to.be.true;
      expect(state.isPaused).to.be.false;

      // Verify USDC was actually transferred
      const prizePoolAfter = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      expect(Number(prizePoolAfter.amount)).to.equal(
        Number(SEED_AMOUNT.toString()),
      );
    });

    it("fails to fund seed a second time", async () => {
      try {
        await program.methods
          .fundSeed()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            authorityUsdc: authorityUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — already funded");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("AlreadyInitialized");
        }
      }
    });
  });

  // ========================================================================
  // 3. PAUSE / UNPAUSE TESTS
  // ========================================================================
  describe("Pause / Unpause", () => {
    it("pauses the lottery", async () => {
      await program.methods
        .pause("Maintenance test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isPaused).to.be.true;
    });

    it("fails to pause from non-authority", async () => {
      try {
        await program.methods
          .pause("Unauthorized pause")
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("unpauses the lottery", async () => {
      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isPaused).to.be.false;
    });

    it("fails to unpause from non-authority", async () => {
      // First pause
      await program.methods
        .pause("Pause for unpause test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      try {
        await program.methods
          .unpause()
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Clean up — unpause for further tests
      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });
  });

  // ========================================================================
  // 4. BUY TICKET TESTS
  // ========================================================================
  describe("Buy Ticket", () => {
    it("buys a single ticket successfully", async () => {
      // Fetch current state to know ticket index
      const stateBefore = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      const drawId = stateBefore.currentDrawId.toNumber();
      const ticketIndex = stateBefore.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      const player1UsdcBefore = await getAccount(
        provider.connection,
        player1Usdc,
      );

      await program.methods
        .buyTicket({
          numbers: [3, 10, 22, 33, 40, 46],
          useFreeTicket: false,
        })
        .accountsPartial({
          player: player1.publicKey,
          lotteryState: pdas.lotteryState,
          ticket: ticketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          houseFeeUsdc: pdas.houseFeeUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
          usdcMint: usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      // Verify ticket was created
      const ticket = await programAccounts.ticketData.fetch(ticketPda);
      expect(ticket.owner.toString()).to.equal(player1.publicKey.toString());
      expect(ticket.drawId.toNumber()).to.equal(drawId);
      // Numbers should be sorted
      expect(ticket.numbers).to.deep.equal([3, 10, 22, 33, 40, 46]);
      expect(ticket.isClaimed).to.be.false;
      expect(ticket.matchCount).to.equal(0);
      expect(ticket.prizeAmount.toNumber()).to.equal(0);
      expect(ticket.syndicate).to.be.null;

      // Verify USDC was deducted from player
      const player1UsdcAfter = await getAccount(
        provider.connection,
        player1Usdc,
      );
      expect(
        Number(player1UsdcBefore.amount) - Number(player1UsdcAfter.amount),
      ).to.equal(TICKET_PRICE.toNumber());

      // Verify lottery state updated
      const stateAfter = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      expect(stateAfter.currentDrawTickets.toNumber()).to.equal(
        ticketIndex + 1,
      );
      expect(stateAfter.totalTicketsSold.toNumber()).to.equal(
        stateBefore.totalTicketsSold.toNumber() + 1,
      );

      // Verify user stats created
      const userStats = await programAccounts.userStats.fetch(userStatsPda);
      expect(userStats.wallet.toString()).to.equal(
        player1.publicKey.toString(),
      );
      expect(userStats.totalTickets.toNumber()).to.equal(1);
      expect(userStats.totalSpent.toString()).to.equal(TICKET_PRICE.toString());
    });

    it("buys a ticket with unsorted numbers (should be stored sorted)", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      await program.methods
        .buyTicket({
          numbers: [46, 1, 30, 15, 8, 23],
          useFreeTicket: false,
        })
        .accountsPartial({
          player: player1.publicKey,
          lotteryState: pdas.lotteryState,
          ticket: ticketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          houseFeeUsdc: pdas.houseFeeUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
          usdcMint: usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      const ticket = await programAccounts.ticketData.fetch(ticketPda);
      // Verify numbers are stored sorted
      expect(ticket.numbers).to.deep.equal([1, 8, 15, 23, 30, 46]);
    });

    it("fails to buy ticket with invalid numbers (out of range - zero)", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      try {
        await program.methods
          .buyTicket({
            numbers: [0, 1, 2, 3, 4, 5],
            useFreeTicket: false,
          })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — number 0 out of range");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("NumbersOutOfRange");
        }
      }
    });

    it("fails to buy ticket with invalid numbers (out of range - too high)", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      try {
        await program.methods
          .buyTicket({
            numbers: [1, 2, 3, 4, 5, 47],
            useFreeTicket: false,
          })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — number 47 out of range");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("NumbersOutOfRange");
        }
      }
    });

    it("fails to buy ticket with duplicate numbers", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      try {
        await program.methods
          .buyTicket({
            numbers: [1, 1, 3, 4, 5, 6],
            useFreeTicket: false,
          })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — duplicate numbers");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("DuplicateNumbers");
        }
      }
    });

    it("second player buys a ticket", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player2.publicKey);

      await program.methods
        .buyTicket({
          numbers: [5, 12, 18, 29, 35, 44],
          useFreeTicket: false,
        })
        .accountsPartial({
          player: player2.publicKey,
          lotteryState: pdas.lotteryState,
          ticket: ticketPda,
          playerUsdc: player2Usdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          houseFeeUsdc: pdas.houseFeeUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
          usdcMint: usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player2])
        .rpc();

      const ticket = await programAccounts.ticketData.fetch(ticketPda);
      expect(ticket.owner.toString()).to.equal(player2.publicKey.toString());
      expect(ticket.numbers).to.deep.equal([5, 12, 18, 29, 35, 44]);
    });

    it("verifies USDC distribution across pools after ticket purchases", async () => {
      const prizePool = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      const houseFee = await getAccount(provider.connection, pdas.houseFeeUsdc);
      const insurance = await getAccount(
        provider.connection,
        pdas.insurancePoolUsdc,
      );

      // Prize pool should have seed + ticket contributions
      expect(Number(prizePool.amount)).to.be.greaterThan(
        Number(SEED_AMOUNT.toString()),
      );

      // House fee should have accumulated fees
      expect(Number(houseFee.amount)).to.be.greaterThan(0);

      // Insurance pool should have insurance contributions
      expect(Number(insurance.amount)).to.be.greaterThan(0);

      // Verify: total deducted from players = ticket_price * num_tickets
      // 3 tickets purchased so far (2 by player1, 1 by player2)
      const totalTicketRevenue = TICKET_PRICE.toNumber() * 3;
      const totalInPools =
        Number(prizePool.amount) -
        Number(SEED_AMOUNT.toString()) +
        Number(houseFee.amount) +
        Number(insurance.amount);
      expect(totalInPools).to.equal(totalTicketRevenue);
    });
  });

  // ========================================================================
  // 5. BUY BULK TICKET TESTS
  // ========================================================================
  describe("Buy Bulk Tickets", () => {
    it("buys multiple tickets in bulk", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [unifiedTicketPda] = deriveUnifiedTicketPDA(
        programId,
        player1.publicKey,
        drawId,
        ticketIndex,
      );
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      const tickets = [
        [2, 8, 14, 20, 26, 32],
        [4, 10, 16, 22, 28, 34],
        [6, 12, 18, 24, 30, 36],
      ];

      await program.methods
        .buyBulk({ tickets })
        .accountsPartial({
          player: player1.publicKey,
          lotteryState: pdas.lotteryState,
          unifiedTicket: unifiedTicketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          houseFeeUsdc: pdas.houseFeeUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
          usdcMint: usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      // Verify unified ticket
      const unified =
        await program.account.unifiedTicket.fetch(unifiedTicketPda);
      expect(unified.owner.toString()).to.equal(player1.publicKey.toString());
      expect(unified.drawId.toNumber()).to.equal(drawId);
      expect(unified.ticketCount).to.equal(3);
      expect(unified.numbers.length).to.equal(3);

      // Numbers should be sorted within each ticket
      expect(unified.numbers[0]).to.deep.equal([2, 8, 14, 20, 26, 32]);
      expect(unified.numbers[1]).to.deep.equal([4, 10, 16, 22, 28, 34]);
      expect(unified.numbers[2]).to.deep.equal([6, 12, 18, 24, 30, 36]);

      // Verify state was updated
      const stateAfter = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      expect(stateAfter.currentDrawTickets.toNumber()).to.equal(
        ticketIndex + 3,
      );

      // Verify user stats incremented
      const userStats = await programAccounts.userStats.fetch(userStatsPda);
      expect(userStats.totalTickets.toNumber()).to.be.greaterThan(3);
    });

    it("fails to buy bulk with empty ticket array", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [unifiedTicketPda] = deriveUnifiedTicketPDA(
        programId,
        player1.publicKey,
        drawId,
        ticketIndex,
      );
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      try {
        await program.methods
          .buyBulk({ tickets: [] })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            unifiedTicket: unifiedTicketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — empty tickets");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("EmptyTicketArray");
        }
      }
    });

    it("fails to buy bulk with invalid numbers in one ticket", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [unifiedTicketPda] = deriveUnifiedTicketPDA(
        programId,
        player1.publicKey,
        drawId,
        ticketIndex,
      );
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      try {
        await program.methods
          .buyBulk({
            tickets: [
              [1, 2, 3, 4, 5, 6],
              [7, 8, 9, 10, 10, 12], // duplicate 10
            ],
          })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            unifiedTicket: unifiedTicketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — duplicate in second ticket");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 6. CONFIG UPDATE TESTS
  // ========================================================================
  describe("Update Config", () => {
    it("updates ticket price", async () => {
      // Pause first for config update (some updates require pause or no draw in progress)
      await program.methods
        .pause("Config update")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const newTicketPrice = new BN(3_000_000); // $3.00
      await program.methods
        .updateConfig({
          ticketPrice: newTicketPrice,
          houseFeeBps: null,
          jackpotCap: null,
          seedAmount: null,
          softCap: null,
          hardCap: null,
          switchboardQueue: null,
          drawInterval: null,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.ticketPrice.toString()).to.equal(newTicketPrice.toString());

      // Restore original price
      await program.methods
        .updateConfig({
          ticketPrice: TICKET_PRICE,
          houseFeeBps: null,
          jackpotCap: null,
          seedAmount: null,
          softCap: null,
          hardCap: null,
          switchboardQueue: null,
          drawInterval: null,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      // Unpause
      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });

    it("fails with invalid cap configuration (soft >= hard)", async () => {
      await program.methods
        .pause("Config update test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      try {
        await program.methods
          .updateConfig({
            ticketPrice: null,
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: HARD_CAP, // soft = hard is invalid
            hardCap: SOFT_CAP, // hard < soft is invalid
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — invalid cap config");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Unpause
      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });

    it("fails to update config from non-authority", async () => {
      try {
        await program.methods
          .updateConfig({
            ticketPrice: new BN(1_000_000),
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("updates draw interval within valid range", async () => {
      await program.methods
        .pause("Config update")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const newInterval = new BN(43200); // 12 hours
      await program.methods
        .updateConfig({
          ticketPrice: null,
          houseFeeBps: null,
          jackpotCap: null,
          seedAmount: null,
          softCap: null,
          hardCap: null,
          switchboardQueue: null,
          drawInterval: newInterval,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.drawInterval.toString()).to.equal(newInterval.toString());

      // Restore
      await program.methods
        .updateConfig({
          ticketPrice: null,
          houseFeeBps: null,
          jackpotCap: null,
          seedAmount: null,
          softCap: null,
          hardCap: null,
          switchboardQueue: null,
          drawInterval: DRAW_INTERVAL,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });

    it("fails with invalid draw interval (too short)", async () => {
      await program.methods
        .pause("Config test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      try {
        await program.methods
          .updateConfig({
            ticketPrice: null,
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: new BN(60), // 1 minute — too short (min 1 hour)
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — invalid draw interval");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("InvalidDrawInterval");
        }
      }

      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });

    it("fails with invalid house fee (> 50%)", async () => {
      await program.methods
        .pause("Config test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      try {
        await program.methods
          .updateConfig({
            ticketPrice: null,
            houseFeeBps: 5001, // > 50%
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — house fee too high");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("InvalidHouseFee");
        }
      }

      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });
  });

  // ========================================================================
  // 7. WITHDRAW HOUSE FEES TESTS
  // ========================================================================
  describe("Withdraw House Fees", () => {
    it("withdraws house fees successfully", async () => {
      const houseFeeAccount = await getAccount(
        provider.connection,
        pdas.houseFeeUsdc,
      );
      const feeBalance = Number(houseFeeAccount.amount);

      // There should be accumulated fees from ticket purchases
      expect(feeBalance).to.be.greaterThan(0);

      const destBefore = await getAccount(provider.connection, destinationUsdc);

      const withdrawAmount = new BN(feeBalance);
      await program.methods
        .withdrawHouseFees(withdrawAmount)
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
          houseFeeUsdc: pdas.houseFeeUsdc,
          destinationUsdc: destinationUsdc,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();

      // Verify house fee account is empty
      const houseFeeAfter = await getAccount(
        provider.connection,
        pdas.houseFeeUsdc,
      );
      expect(Number(houseFeeAfter.amount)).to.equal(0);

      // Verify destination received the fees
      const destAfter = await getAccount(provider.connection, destinationUsdc);
      expect(Number(destAfter.amount) - Number(destBefore.amount)).to.equal(
        feeBalance,
      );
    });

    it("fails to withdraw zero amount", async () => {
      try {
        await program.methods
          .withdrawHouseFees(new BN(0))
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            houseFeeUsdc: pdas.houseFeeUsdc,
            destinationUsdc: destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — zero amount");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to withdraw from non-authority", async () => {
      try {
        await program.methods
          .withdrawHouseFees(new BN(1))
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
            houseFeeUsdc: pdas.houseFeeUsdc,
            destinationUsdc: destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 8. ADD RESERVE FUNDS TESTS
  // ========================================================================
  describe("Add Reserve Funds", () => {
    it("adds reserve funds successfully", async () => {
      const stateBefore = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      const reserveBefore = stateBefore.reserveBalance.toNumber();

      const addAmount = new BN(10_000_000_000); // $10,000
      await program.methods
        .addReserveFunds(addAmount)
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
          authorityUsdc: authorityUsdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();

      const stateAfter = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      expect(stateAfter.reserveBalance.toNumber()).to.equal(
        reserveBefore + addAmount.toNumber(),
      );
    });

    it("fails to add zero reserve funds", async () => {
      try {
        await program.methods
          .addReserveFunds(new BN(0))
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            authorityUsdc: authorityUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — zero amount");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 9. AUTHORITY TRANSFER TESTS (Two-Step)
  // ========================================================================
  describe("Authority Transfer (Two-Step)", () => {
    const newAuthority = Keypair.generate();

    before(async () => {
      await airdrop(provider, newAuthority.publicKey);
    });

    it("proposes authority transfer", async () => {
      await program.methods
        .proposeAuthority(newAuthority.publicKey)
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.pendingAuthority.toString()).to.equal(
        newAuthority.publicKey.toString(),
      );
    });

    it("fails to propose self as new authority", async () => {
      try {
        await program.methods
          .proposeAuthority(authority.publicKey)
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — cannot propose self");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("InvalidAuthority");
        }
      }
    });

    it("fails to accept from wrong account", async () => {
      try {
        await program.methods
          .acceptAuthority()
          .accountsPartial({
            newAuthority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — wrong account");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("cancels authority transfer", async () => {
      await program.methods
        .cancelAuthorityTransfer()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.pendingAuthority).to.be.null;
    });

    it("completes full authority transfer and transfer back", async () => {
      // Step 1: Propose
      await program.methods
        .proposeAuthority(newAuthority.publicKey)
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      // Step 2: Accept
      await program.methods
        .acceptAuthority()
        .accountsPartial({
          newAuthority: newAuthority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .signers([newAuthority])
        .rpc();

      let state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.authority.toString()).to.equal(
        newAuthority.publicKey.toString(),
      );
      expect(state.pendingAuthority).to.be.null;

      // Transfer back to original authority
      await program.methods
        .proposeAuthority(authority.publicKey)
        .accountsPartial({
          authority: newAuthority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .signers([newAuthority])
        .rpc();

      await program.methods
        .acceptAuthority()
        .accountsPartial({
          newAuthority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.authority.toString()).to.equal(
        authority.publicKey.toString(),
      );
    });
  });

  // ========================================================================
  // 10. DIRECT AUTHORITY TRANSFER TEST
  // ========================================================================
  describe("Direct Authority Transfer", () => {
    const tempAuthority = Keypair.generate();

    before(async () => {
      await airdrop(provider, tempAuthority.publicKey);
    });

    it("transfers authority directly and back", async () => {
      await program.methods
        .transferAuthority()
        .accountsPartial({
          authority: authority.publicKey,
          newAuthority: tempAuthority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .signers([tempAuthority])
        .rpc();

      let state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.authority.toString()).to.equal(
        tempAuthority.publicKey.toString(),
      );

      // Transfer back
      await program.methods
        .transferAuthority()
        .accountsPartial({
          authority: tempAuthority.publicKey,
          newAuthority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .signers([tempAuthority])
        .rpc();

      state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.authority.toString()).to.equal(
        authority.publicKey.toString(),
      );
    });
  });

  // ========================================================================
  // 11. SYNDICATE TESTS
  // ========================================================================
  describe("Syndicates", () => {
    const syndicateId = new BN(1);
    let syndicatePda: PublicKey;
    let syndicateUsdcAccount: PublicKey;

    before(async () => {
      [syndicatePda] = deriveSyndicatePDA(programId, syndicateId);
    });

    it("creates a syndicate", async () => {
      // Create USDC account for syndicate
      syndicateUsdcAccount = await createAndFundUsdcAccount(
        provider,
        usdcMint,
        syndicatePda, // owner is the syndicate PDA, but createAccount needs the actual owner
        authority,
        BigInt(0),
      );

      // The syndicate USDC account should be owned by the syndicate PDA.
      // However, SPL token accounts need the owner to sign for transfers.
      // In practice, the program creates this. For the test, we'll create
      // it as a regular token account and let the program manage it via PDA.
      // Actually the program expects the syndicate_usdc to be a token account
      // whose owner field is syndicatePda. Let's use a regular account
      // with authority as the "true" owner for now, since creating PDA-owned
      // token accounts outside the program is complex.

      // Let's try the actual instruction — it creates the syndicate PDA and expects
      // us to pass a USDC account.
      // Looking at the code, syndicate_usdc is just passed as a token account.
      // The program stores its key. We need to pre-create it.

      await program.methods
        .createSyndicate({
          syndicateId: syndicateId,
          name: "Test Syndicate",
          isPublic: true,
          managerFeeBps: 200, // 2%
        })
        .accountsPartial({
          creator: player1.publicKey,
          syndicate: syndicatePda,
          syndicateUsdc: syndicateUsdcAccount,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda);
      expect(syndicate.creator.toString()).to.equal(
        player1.publicKey.toString(),
      );
      expect(syndicate.name).to.equal("Test Syndicate");
      expect(syndicate.isPublic).to.be.true;
      expect(syndicate.managerFeeBps).to.equal(200);
      expect(syndicate.memberCount).to.be.greaterThanOrEqual(1); // Creator is first member
    });

    it("fails to create syndicate with fee > 5%", async () => {
      const badSyndicateId = new BN(999);
      const [badSyndicatePda] = deriveSyndicatePDA(programId, badSyndicateId);

      const badSyndicateUsdc = await createAndFundUsdcAccount(
        provider,
        usdcMint,
        badSyndicatePda,
        authority,
        BigInt(0),
      );

      try {
        await program.methods
          .createSyndicate({
            syndicateId: badSyndicateId,
            name: "Bad Syndicate",
            isPublic: true,
            managerFeeBps: 600, // 6% > max 5%
          })
          .accountsPartial({
            creator: player1.publicKey,
            syndicate: badSyndicatePda,
            syndicateUsdc: badSyndicateUsdc,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — fee too high");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to create syndicate with name too long", async () => {
      const badSyndicateId = new BN(998);
      const [badSyndicatePda] = deriveSyndicatePDA(programId, badSyndicateId);

      const badSyndicateUsdc = await createAndFundUsdcAccount(
        provider,
        usdcMint,
        badSyndicatePda,
        authority,
        BigInt(0),
      );

      try {
        await program.methods
          .createSyndicate({
            syndicateId: badSyndicateId,
            name: "A".repeat(33), // 33 chars > max 32
            isPublic: true,
            managerFeeBps: 200,
          })
          .accountsPartial({
            creator: player1.publicKey,
            syndicate: badSyndicatePda,
            syndicateUsdc: badSyndicateUsdc,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — name too long");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("player2 joins the syndicate", async () => {
      const [userStatsPda] = deriveUserStatsPDA(programId, player2.publicKey);

      const contribution = new BN(5_000_000); // $5

      await program.methods
        .joinSyndicate({ contribution })
        .accountsPartial({
          member: player2.publicKey,
          syndicate: syndicatePda,
          memberUsdc: player2Usdc,
          syndicateUsdc: syndicateUsdcAccount,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player2])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda);
      expect(syndicate.memberCount).to.be.greaterThanOrEqual(2);
    });

    it("updates syndicate config (manager only)", async () => {
      await program.methods
        .updateSyndicateConfig({
          name: "Updated Syndicate",
          isPublic: false,
          managerFeeBps: 300, // 3%
        })
        .accountsPartial({
          manager: player1.publicKey,
          syndicate: syndicatePda,
        })
        .signers([player1])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda);
      expect(syndicate.name).to.equal("Updated Syndicate");
      expect(syndicate.isPublic).to.be.false;
      expect(syndicate.managerFeeBps).to.equal(300);
    });

    it("fails to update syndicate config from non-manager", async () => {
      try {
        await program.methods
          .updateSyndicateConfig({
            name: "Hacked",
            isPublic: true,
            managerFeeBps: 0,
          })
          .accountsPartial({
            manager: player2.publicKey,
            syndicate: syndicatePda,
          })
          .signers([player2])
          .rpc();
        expect.fail("Should have thrown — not manager");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 12. EMERGENCY FUND TRANSFER TESTS
  // ========================================================================
  describe("Emergency Fund Transfer", () => {
    it("fails when lottery is not paused", async () => {
      // Ensure unpaused
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      if (state.isPaused) {
        await program.methods
          .unpause()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
      }

      try {
        await program.methods
          .emergencyFundTransfer(
            { reserve: {} }, // FundSource::Reserve
            new BN(1_000_000),
            "Test emergency",
          )
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            destinationUsdc: destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — not paused");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("transfers funds from reserve when paused", async () => {
      // Pause
      await program.methods
        .pause("Emergency test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const stateBefore = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      const reserveBefore = stateBefore.reserveBalance.toNumber();

      if (reserveBefore > 0) {
        const transferAmount = new BN(Math.min(reserveBefore, 1_000_000_000)); // $1,000 or less

        await program.methods
          .emergencyFundTransfer(
            { reserve: {} },
            transferAmount,
            "Reserve emergency transfer test",
          )
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            destinationUsdc: destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();

        const stateAfter = await programAccounts.lotteryState.fetch(
          pdas.lotteryState,
        );
        expect(stateAfter.reserveBalance.toNumber()).to.be.lessThan(
          reserveBefore,
        );
      }

      // Unpause
      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });

    it("fails from non-authority", async () => {
      await program.methods
        .pause("Auth test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      try {
        await program.methods
          .emergencyFundTransfer({ reserve: {} }, new BN(1), "Unauthorized")
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            destinationUsdc: destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      await program.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });
  });

  // ========================================================================
  // 13. LOTTERY STATE INVARIANTS
  // ========================================================================
  describe("State Invariants", () => {
    it("lottery state has consistent data after all operations", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);

      // Authority is the original authority
      expect(state.authority.toString()).to.equal(
        authority.publicKey.toString(),
      );

      // Lottery is funded and not paused
      expect(state.isFunded).to.be.true;
      expect(state.isPaused).to.be.false;

      // Draw is not in progress
      expect(state.isDrawInProgress).to.be.false;

      // Draw ID is 1 (no draws have been executed)
      expect(state.currentDrawId.toNumber()).to.equal(1);

      // Tickets sold > 0
      expect(state.totalTicketsSold.toNumber()).to.be.greaterThan(0);

      // Jackpot should be at least seed amount (since no draws happened)
      expect(state.jackpotBalance.toNumber()).to.be.greaterThanOrEqual(
        SEED_AMOUNT.toNumber(),
      );

      // Prize caps are correct
      expect(state.softCap.toString()).to.equal(SOFT_CAP.toString());
      expect(state.hardCap.toString()).to.equal(HARD_CAP.toString());

      // No pending authority transfer
      expect(state.pendingAuthority).to.be.null;
    });

    it("user stats are consistent for player1", async () => {
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);
      const stats = await programAccounts.userStats.fetch(userStatsPda);

      expect(stats.wallet.toString()).to.equal(player1.publicKey.toString());
      expect(stats.totalTickets.toNumber()).to.be.greaterThan(0);
      expect(stats.totalSpent.toNumber()).to.be.greaterThan(0);
      expect(stats.totalWon.toNumber()).to.equal(0); // No prizes claimed yet
      expect(stats.jackpotWins.toNumber()).to.equal(0);
    });

    it("verifies token account balances are non-negative", async () => {
      const prizePool = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      const insurance = await getAccount(
        provider.connection,
        pdas.insurancePoolUsdc,
      );
      const houseFee = await getAccount(provider.connection, pdas.houseFeeUsdc);

      expect(Number(prizePool.amount)).to.be.greaterThanOrEqual(0);
      expect(Number(insurance.amount)).to.be.greaterThanOrEqual(0);
      expect(Number(houseFee.amount)).to.be.greaterThanOrEqual(0);
    });
  });

  // ========================================================================
  // 14. MULTIPLE TICKET PURCHASES BY SAME PLAYER
  // ========================================================================
  describe("User Ticket Tracking", () => {
    it("tracks tickets_this_draw correctly across purchases", async () => {
      const [userStatsPda] = deriveUserStatsPDA(programId, player2.publicKey);

      // Buy a few more tickets for player2
      for (let i = 0; i < 3; i++) {
        const state = await program.account.lotteryState.fetch(
          pdas.lotteryState,
        );
        const drawId = state.currentDrawId.toNumber();
        const ticketIndex = state.currentDrawTickets.toNumber();
        const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);

        await program.methods
          .buyTicket({
            numbers: [
              (i * 6 + 1) % 46 || 1,
              (i * 6 + 2) % 46 || 2,
              (i * 6 + 3) % 46 || 3,
              (i * 6 + 4) % 46 || 4,
              (i * 6 + 5) % 46 || 5,
              (i * 6 + 6) % 46 || 6,
            ],
            useFreeTicket: false,
          })
          .accountsPartial({
            player: player2.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: player2Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player2])
          .rpc();
      }

      const userStats = await programAccounts.userStats.fetch(userStatsPda);
      // Player2 bought 1 ticket earlier + 3 more = 4 total
      expect(userStats.totalTickets.toNumber()).to.be.greaterThanOrEqual(4);
      expect(userStats.ticketsThisDraw.toNumber()).to.be.greaterThanOrEqual(3);
    });

    it("tracks streak correctly", async () => {
      const [userStatsPda] = deriveUserStatsPDA(programId, player2.publicKey);
      const userStats = await programAccounts.userStats.fetch(userStatsPda);

      // Player has participated in draw 1, so streak should be >= 1
      expect(userStats.currentStreak.toNumber()).to.be.greaterThanOrEqual(1);
      expect(userStats.bestStreak.toNumber()).to.be.greaterThanOrEqual(1);
    });
  });

  // ========================================================================
  // 15. EDGE CASE: BUYING TICKET WITH INSUFFICIENT USDC
  // ========================================================================
  describe("Insufficient Funds", () => {
    it("fails when player has insufficient USDC", async () => {
      const brokePlayer = Keypair.generate();
      await airdrop(provider, brokePlayer.publicKey);

      // Create USDC account with $0
      const brokeUsdc = await createAndFundUsdcAccount(
        provider,
        usdcMint,
        brokePlayer.publicKey,
        authority,
        BigInt(0), // No USDC
      );

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(
        programId,
        brokePlayer.publicKey,
      );

      try {
        await program.methods
          .buyTicket({
            numbers: [1, 2, 3, 4, 5, 6],
            useFreeTicket: false,
          })
          .accountsPartial({
            player: brokePlayer.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: brokeUsdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([brokePlayer])
          .rpc();
        expect.fail("Should have thrown — insufficient USDC");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("InsufficientFunds");
        }
      }
    });
  });

  // ========================================================================
  // 16. FREE TICKET TESTS
  // ========================================================================
  describe("Free Tickets", () => {
    it("fails to use free ticket when none available", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();

      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      // Check that player1 has 0 free tickets
      const userStats = await programAccounts.userStats.fetch(userStatsPda);
      expect(userStats.freeTicketsAvailable).to.equal(0);

      try {
        await program.methods
          .buyTicket({
            numbers: [1, 2, 3, 4, 5, 6],
            useFreeTicket: true, // Request free ticket
          })
          .accountsPartial({
            player: player1.publicKey,
            lotteryState: pdas.lotteryState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: pdas.prizePoolUsdc,
            houseFeeUsdc: pdas.houseFeeUsdc,
            insurancePoolUsdc: pdas.insurancePoolUsdc,
            usdcMint: usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — no free tickets");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("NoFreeTicketsAvailable");
        }
      }
    });
  });

  // ========================================================================
  // 17. DRAW LIFECYCLE TESTS
  // ========================================================================
  // NOTE: commit_randomness and execute_draw require Switchboard on localnet.
  // These tests document the expected flow and will pass once Switchboard
  // is available on the test validator (e.g., via switchboard-oracle CLI).
  describe("Draw Lifecycle (requires Switchboard)", () => {
    it("commit_randomness fails when draw time has not arrived", async () => {
      // The next_draw_timestamp is set far in the future after initialization.
      // commit_randomness requires clock >= next_draw_timestamp - TICKET_SALE_CUTOFF
      // So it should fail if we call it too early.

      // We use a random keypair as the "randomness account" since Switchboard
      // isn't available. The call will likely fail at the timestamp check first.
      const fakeRandomnessAccount = Keypair.generate();

      try {
        await program.methods
          .commitRandomness()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            randomnessAccountData: fakeRandomnessAccount.publicKey,
            switchboardQueue: switchboardQueue,
            systemProgram: SystemProgram.programId,
          })
          .rpc();
        expect.fail("Should have thrown — draw not ready");
      } catch (err: unknown) {
        expect(err).to.exist;
        // Could be DrawNotReady or a Switchboard parse error
      }
    });

    it("execute_draw fails when no draw is in progress", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isDrawInProgress).to.be.false;

      const [drawResultPda] = deriveDrawResultPDA(
        programId,
        state.currentDrawId.toNumber(),
      );
      const fakeRandomnessAccount = Keypair.generate();

      try {
        await program.methods
          .executeDraw()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            drawResult: drawResultPda,
            randomnessAccountData: fakeRandomnessAccount.publicKey,
            payer: authority.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .rpc();
        expect.fail("Should have thrown — no draw in progress");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("finalize_draw fails when no draw result exists", async () => {
      // There's no draw result account for draw 1 yet
      const [drawResultPda] = deriveDrawResultPDA(programId, 1);

      try {
        await program.methods
          .finalizeDraw({
            winnerCounts: {
              match6: 0,
              match5: 0,
              match4: 1,
              match3: 5,
              match2: 10,
            },
            verificationHash: Array(32).fill(0),
            indexerNonce: new anchor.BN(0),
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            drawResult: drawResultPda,
          })
          .rpc();
        expect.fail("Should have thrown — draw result doesn't exist");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 18. CANCEL DRAW AND FORCE FINALIZE TESTS
  // ========================================================================
  describe("Cancel / Force Finalize Draw", () => {
    it("cancel_draw fails when no draw is in progress", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isDrawInProgress).to.be.false;

      try {
        await program.methods
          .cancelDraw()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — no draw in progress");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("force_finalize_draw fails when no draw is in progress", async () => {
      try {
        await program.methods
          .forceFinalizeDraw("Testing force finalize")
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — no draw in progress");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("cancel_draw fails from non-authority", async () => {
      try {
        await program.methods
          .cancelDraw()
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 19. TICKET FUND ALLOCATION VERIFICATION
  // ========================================================================
  describe("Fund Allocation Math", () => {
    it("verifies ticket price split matches expected allocation", async () => {
      // Buy a single ticket and verify the exact fund distribution
      const prizePoolBefore = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      const houseFeeBefore = await getAccount(
        provider.connection,
        pdas.houseFeeUsdc,
      );
      const insuranceBefore = await getAccount(
        provider.connection,
        pdas.insurancePoolUsdc,
      );

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const drawId = state.currentDrawId.toNumber();
      const ticketIndex = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveTicketPDA(programId, drawId, ticketIndex);
      const [userStatsPda] = deriveUserStatsPDA(programId, player1.publicKey);

      await program.methods
        .buyTicket({
          numbers: [7, 14, 21, 28, 35, 42],
          useFreeTicket: false,
        })
        .accountsPartial({
          player: player1.publicKey,
          lotteryState: pdas.lotteryState,
          ticket: ticketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: pdas.prizePoolUsdc,
          houseFeeUsdc: pdas.houseFeeUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
          usdcMint: usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      const prizePoolAfter = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      const houseFeeAfter = await getAccount(
        provider.connection,
        pdas.houseFeeUsdc,
      );
      const insuranceAfter = await getAccount(
        provider.connection,
        pdas.insurancePoolUsdc,
      );

      const prizePoolDelta =
        Number(prizePoolAfter.amount) - Number(prizePoolBefore.amount);
      const houseFeeDelta =
        Number(houseFeeAfter.amount) - Number(houseFeeBefore.amount);
      const insuranceDelta =
        Number(insuranceAfter.amount) - Number(insuranceBefore.amount);

      // Total should equal ticket price
      const totalDelta = prizePoolDelta + houseFeeDelta + insuranceDelta;
      expect(totalDelta).to.equal(TICKET_PRICE.toNumber());

      // House fee should be 28% of ticket price (at tier 1, jackpot < $500k...
      // but our jackpot is $500k from seed, so it might be tier 2 at 32%)
      // The exact tier depends on current jackpot balance.
      // Just verify the split is sensible:
      expect(houseFeeDelta).to.be.greaterThan(0);
      expect(prizePoolDelta).to.be.greaterThan(0);
      expect(insuranceDelta).to.be.greaterThanOrEqual(0);

      // House fee should be between 28% and 40% of ticket price
      const houseFeePct = (houseFeeDelta / TICKET_PRICE.toNumber()) * 100;
      expect(houseFeePct).to.be.greaterThanOrEqual(27); // Allow rounding
      expect(houseFeePct).to.be.lessThanOrEqual(41);
    });
  });

  // ========================================================================
  // 20. COMPREHENSIVE ACCESS CONTROL SUMMARY
  // ========================================================================
  describe("Access Control Summary", () => {
    it("unauthorized user cannot perform any admin action", async () => {
      const actions = [
        // pause
        () =>
          program.methods
            .pause("hack")
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: pdas.lotteryState,
            })
            .signers([unauthorizedUser])
            .rpc(),
        // withdraw_house_fees
        () =>
          program.methods
            .withdrawHouseFees(new BN(1))
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: pdas.lotteryState,
              houseFeeUsdc: pdas.houseFeeUsdc,
              destinationUsdc: destinationUsdc,
              tokenProgram: TOKEN_PROGRAM_ID,
            })
            .signers([unauthorizedUser])
            .rpc(),
        // propose_authority
        () =>
          program.methods
            .proposeAuthority(unauthorizedUser.publicKey)
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: pdas.lotteryState,
            })
            .signers([unauthorizedUser])
            .rpc(),
        // cancel_draw
        () =>
          program.methods
            .cancelDraw()
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: pdas.lotteryState,
            })
            .signers([unauthorizedUser])
            .rpc(),
        // force_finalize_draw
        () =>
          program.methods
            .forceFinalizeDraw("hack")
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: pdas.lotteryState,
            })
            .signers([unauthorizedUser])
            .rpc(),
      ];

      for (const action of actions) {
        try {
          await action();
          expect.fail("Should have thrown — unauthorized");
        } catch (err: unknown) {
          expect(err).to.exist;
          // All should fail with Unauthorized or a constraint error
        }
      }
    });
  });

  // ========================================================================
  // 21. DYNAMIC FEE TIER VERIFICATION
  // ========================================================================
  describe("Dynamic Fee Tiers", () => {
    it("verifies fee tier is set correctly in state", async () => {
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      const jackpot = state.jackpotBalance.toNumber();

      // Fee tiers:
      // < $500k: 2800 bps (28%)
      // $500k-$1M: 3200 bps (32%)
      // $1M-$1.5M: 3600 bps (36%)
      // > $1.5M: 4000 bps (40%)
      const tier1 = 500_000_000_000;
      const tier2 = 1_000_000_000_000;
      const tier3 = 1_500_000_000_000;

      let expectedBps: number;
      if (jackpot < tier1) {
        expectedBps = 2800;
      } else if (jackpot < tier2) {
        expectedBps = 3200;
      } else if (jackpot < tier3) {
        expectedBps = 3600;
      } else {
        expectedBps = 4000;
      }

      expect(state.houseFeeBps).to.equal(expectedBps);
    });
  });

  // ========================================================================
  // 22. CONFIG TIMELOCK (propose / cancel / execute)
  // ========================================================================
  describe("Config Timelock", () => {
    it("proposes a config change (starts timelock)", async () => {
      const stateBefore = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      expect(stateBefore.configTimelockEnd.toNumber()).to.equal(0);

      await program.methods
        .proposeConfig({
          ticketPrice: new BN(3_000_000), // $3.00
          houseFeeBps: null,
          jackpotCap: null,
          seedAmount: null,
          softCap: null,
          hardCap: null,
          switchboardQueue: null,
          drawInterval: null,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const stateAfter = await programAccounts.lotteryState.fetch(
        pdas.lotteryState,
      );
      // Timelock should now be set (> 0)
      expect(stateAfter.configTimelockEnd.toNumber()).to.be.greaterThan(0);
      // Pending config hash should be non-zero
      const hashBytes = stateAfter.pendingConfigHash as number[];
      const hasNonZero = hashBytes.some((b: number) => b !== 0);
      expect(hasNonZero).to.be.true;
    });

    it("fails to propose when a proposal is already pending", async () => {
      try {
        await program.methods
          .proposeConfig({
            ticketPrice: new BN(4_000_000),
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — proposal already pending");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("cancels the pending config proposal", async () => {
      await program.methods
        .cancelConfigProposal()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.configTimelockEnd.toNumber()).to.equal(0);
      const hashBytes = state.pendingConfigHash as number[];
      const allZero = hashBytes.every((b: number) => b === 0);
      expect(allZero).to.be.true;
    });

    it("fails to cancel when no proposal is pending", async () => {
      try {
        await program.methods
          .cancelConfigProposal()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — no proposal pending");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to propose config from non-authority", async () => {
      try {
        await program.methods
          .proposeConfig({
            ticketPrice: new BN(3_000_000),
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — not authority");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("execute_config fails when timelock has not expired", async () => {
      // First propose a config change
      await program.methods
        .proposeConfig({
          ticketPrice: new BN(3_000_000),
          houseFeeBps: null,
          jackpotCap: null,
          seedAmount: null,
          softCap: null,
          hardCap: null,
          switchboardQueue: null,
          drawInterval: null,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();

      // Immediately try to execute — timelock is 24 hours, so this should fail
      try {
        await program.methods
          .executeConfig({
            ticketPrice: new BN(3_000_000),
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — timelock not expired");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Clean up: cancel the pending proposal
      await program.methods
        .cancelConfigProposal()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
        })
        .rpc();
    });

    it("fails to propose config with invalid params (soft >= hard cap)", async () => {
      try {
        await program.methods
          .proposeConfig({
            ticketPrice: null,
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: new BN(3_000_000_000_000), // $3M
            hardCap: new BN(1_000_000_000_000), // $1M — less than soft cap
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — soft cap >= hard cap");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to propose config with invalid house fee (> 50%)", async () => {
      try {
        await program.methods
          .proposeConfig({
            ticketPrice: null,
            houseFeeBps: 6000, // 60% > 50% max
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — house fee too high");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to propose config with invalid draw interval (< 1 hour)", async () => {
      try {
        await program.methods
          .proposeConfig({
            ticketPrice: null,
            houseFeeBps: null,
            jackpotCap: null,
            seedAmount: null,
            softCap: null,
            hardCap: null,
            switchboardQueue: null,
            drawInterval: new BN(1800), // 30 min < 1 hour minimum
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
          })
          .rpc();
        expect.fail("Should have thrown — draw interval too short");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 23. CHECK SOLVENCY (permissionless)
  // ========================================================================
  describe("Check Solvency", () => {
    it("solvency check passes after normal operations", async () => {
      // Anyone can call solvency check — use player1 (not authority)
      await program.methods
        .checkSolvency()
        .accountsPartial({
          caller: player1.publicKey,
          lotteryState: pdas.lotteryState,
          prizePoolUsdc: pdas.prizePoolUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
        })
        .signers([player1])
        .rpc();

      // Lottery should NOT be paused after a passing solvency check
      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isPaused).to.be.false;
    });

    it("unauthorized user can also call solvency check (permissionless)", async () => {
      await program.methods
        .checkSolvency()
        .accountsPartial({
          caller: unauthorizedUser.publicKey,
          lotteryState: pdas.lotteryState,
          prizePoolUsdc: pdas.prizePoolUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
        })
        .signers([unauthorizedUser])
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isPaused).to.be.false;
    });

    it("authority can call solvency check", async () => {
      await program.methods
        .checkSolvency()
        .accountsPartial({
          caller: authority.publicKey,
          lotteryState: pdas.lotteryState,
          prizePoolUsdc: pdas.prizePoolUsdc,
          insurancePoolUsdc: pdas.insurancePoolUsdc,
        })
        .rpc();

      const state = await programAccounts.lotteryState.fetch(pdas.lotteryState);
      expect(state.isPaused).to.be.false;
    });
  });

  // ========================================================================
  // 24. SYNDICATE ADVANCED OPERATIONS
  // ========================================================================
  describe("Syndicate Advanced Operations", () => {
    // Re-derive syndicate PDA and USDC PDA for the syndicate created earlier
    const syndicateId = new BN(1);
    let syndicatePda: PublicKey;
    let syndicateUsdcPda: PublicKey;

    before(async () => {
      // Derive the correct syndicate PDA using original creator (player1)
      [syndicatePda] = PublicKey.findProgramAddressSync(
        [
          SYNDICATE_SEED,
          player1.publicKey.toBuffer(),
          syndicateId.toArrayLike(Buffer, "le", 8),
        ],
        programId,
      );

      // Derive the syndicate USDC PDA
      [syndicateUsdcPda] = PublicKey.findProgramAddressSync(
        [SYNDICATE_SEED, Buffer.from("usdc"), syndicatePda.toBuffer()],
        programId,
      );
    });

    it("transfer syndicate creator from player1 to player2", async () => {
      await program.methods
        .transferSyndicateCreator({
          newCreator: player2.publicKey,
        })
        .accountsPartial({
          creator: player1.publicKey,
          syndicate: syndicatePda,
        })
        .signers([player1])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda);
      expect(syndicate.creator.toString()).to.equal(
        player2.publicKey.toString(),
      );
      // original_creator should still be player1
      expect(syndicate.originalCreator.toString()).to.equal(
        player1.publicKey.toString(),
      );
    });

    it("fails to transfer creator from non-creator", async () => {
      try {
        await program.methods
          .transferSyndicateCreator({
            newCreator: unauthorizedUser.publicKey,
          })
          .accountsPartial({
            creator: player1.publicKey, // player1 is no longer creator
            syndicate: syndicatePda,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — not the creator");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("transfers creator back to player1", async () => {
      await program.methods
        .transferSyndicateCreator({
          newCreator: player1.publicKey,
        })
        .accountsPartial({
          creator: player2.publicKey,
          syndicate: syndicatePda,
        })
        .signers([player2])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda);
      expect(syndicate.creator.toString()).to.equal(
        player1.publicKey.toString(),
      );
    });

    it("player2 leaves the syndicate and receives refund", async () => {
      const syndicateBefore =
        await program.account.syndicate.fetch(syndicatePda);
      const memberCountBefore = syndicateBefore.memberCount;

      await program.methods
        .leaveSyndicate()
        .accountsPartial({
          member: player2.publicKey,
          syndicate: syndicatePda,
          memberUsdc: player2Usdc,
          syndicateUsdc: syndicateUsdcPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player2])
        .rpc();

      const syndicateAfter =
        await program.account.syndicate.fetch(syndicatePda);
      expect(syndicateAfter.memberCount).to.equal(memberCountBefore - 1);
    });

    it("fails to leave syndicate when not a member", async () => {
      try {
        await program.methods
          .leaveSyndicate()
          .accountsPartial({
            member: unauthorizedUser.publicKey,
            syndicate: syndicatePda,
            memberUsdc: destinationUsdc,
            syndicateUsdc: syndicateUsdcPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — not a member");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("creator closes the syndicate when only creator remains", async () => {
      const syndicate = await programAccounts.syndicate.fetch(syndicatePda);
      // Only creator should remain
      expect(syndicate.memberCount).to.equal(1);

      await program.methods
        .closeSyndicate()
        .accountsPartial({
          creator: player1.publicKey,
          syndicate: syndicatePda,
          creatorUsdc: player1Usdc,
          syndicateUsdc: syndicateUsdcPda,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([player1])
        .rpc();

      // Syndicate account should be closed (fetch should fail)
      try {
        await program.account.syndicate.fetch(syndicatePda);
        expect.fail("Should have thrown — account should be closed");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to close syndicate that does not exist", async () => {
      try {
        await program.methods
          .closeSyndicate()
          .accountsPartial({
            creator: player1.publicKey,
            syndicate: syndicatePda,
            creatorUsdc: player1Usdc,
            syndicateUsdc: syndicateUsdcPda,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — syndicate already closed");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 25. SYNDICATE – CREATE, CONTRIBUTE, WITHDRAW, AND REMOVE MEMBER
  // ========================================================================
  describe("Syndicate Withdraw & Remove Member", () => {
    const syndicateId2 = new BN(2);
    let syndicatePda2: PublicKey;
    let syndicateUsdcPda2: PublicKey;

    before(async () => {
      [syndicatePda2] = PublicKey.findProgramAddressSync(
        [
          SYNDICATE_SEED,
          player1.publicKey.toBuffer(),
          syndicateId2.toArrayLike(Buffer, "le", 8),
        ],
        programId,
      );

      [syndicateUsdcPda2] = PublicKey.findProgramAddressSync(
        [SYNDICATE_SEED, Buffer.from("usdc"), syndicatePda2.toBuffer()],
        programId,
      );
    });

    it("creates a second syndicate for testing", async () => {
      await program.methods
        .createSyndicate({
          syndicateId: syndicateId2,
          name: "Withdraw Test Syndicate",
          isPublic: true,
          managerFeeBps: 100, // 1%
        })
        .accountsPartial({
          creator: player1.publicKey,
          syndicate: syndicatePda2,
          syndicateUsdc: syndicateUsdcPda2,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda2);
      expect(syndicate.memberCount).to.equal(1);
    });

    it("player2 joins the second syndicate with contribution", async () => {
      const [userStatsPda] = deriveUserStatsPDA(programId, player2.publicKey);
      const contribution = new BN(2_000_000); // $2

      await program.methods
        .joinSyndicate({ contribution })
        .accountsPartial({
          member: player2.publicKey,
          syndicate: syndicatePda2,
          memberUsdc: player2Usdc,
          syndicateUsdc: syndicateUsdcPda2,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player2])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda2);
      expect(syndicate.memberCount).to.equal(2);
      expect(syndicate.totalContribution.toNumber()).to.equal(2_000_000);
    });

    it("creator (player1) removes player2 from syndicate", async () => {
      const syndicateBefore =
        await program.account.syndicate.fetch(syndicatePda2);
      const memberCountBefore = syndicateBefore.memberCount;

      await program.methods
        .removeSyndicateMember({
          memberWallet: player2.publicKey,
        })
        .accountsPartial({
          manager: player1.publicKey,
          syndicate: syndicatePda2,
          memberUsdc: player2Usdc,
          syndicateUsdc: syndicateUsdcPda2,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([player1])
        .rpc();

      const syndicateAfter =
        await program.account.syndicate.fetch(syndicatePda2);
      expect(syndicateAfter.memberCount).to.equal(memberCountBefore - 1);
    });

    it("fails to remove member from non-manager", async () => {
      // Re-add player2 first
      const [userStatsPda] = deriveUserStatsPDA(programId, player2.publicKey);
      const contribution = new BN(1_000_000); // $1

      await program.methods
        .joinSyndicate({ contribution })
        .accountsPartial({
          member: player2.publicKey,
          syndicate: syndicatePda2,
          memberUsdc: player2Usdc,
          syndicateUsdc: syndicateUsdcPda2,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player2])
        .rpc();

      // Now try to remove from non-manager
      try {
        await program.methods
          .removeSyndicateMember({
            memberWallet: player2.publicKey,
          })
          .accountsPartial({
            manager: player2.publicKey,
            syndicate: syndicatePda2,
            memberUsdc: player2Usdc,
            syndicateUsdc: syndicateUsdcPda2,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([player2])
          .rpc();
        expect.fail("Should have thrown — not the manager");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("player2 leaves the second syndicate", async () => {
      await program.methods
        .leaveSyndicate()
        .accountsPartial({
          member: player2.publicKey,
          syndicate: syndicatePda2,
          memberUsdc: player2Usdc,
          syndicateUsdc: syndicateUsdcPda2,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player2])
        .rpc();

      const syndicate = await programAccounts.syndicate.fetch(syndicatePda2);
      expect(syndicate.memberCount).to.equal(1);
    });

    it("closes the second syndicate", async () => {
      await program.methods
        .closeSyndicate()
        .accountsPartial({
          creator: player1.publicKey,
          syndicate: syndicatePda2,
          creatorUsdc: player1Usdc,
          syndicateUsdc: syndicateUsdcPda2,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([player1])
        .rpc();

      try {
        await program.account.syndicate.fetch(syndicatePda2);
        expect.fail("Should have thrown — account closed");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 26. SYNDICATE WARS (Initialize + Edge Cases)
  // ========================================================================
  describe("Syndicate Wars", () => {
    const syndicateId3 = new BN(3);
    let syndicatePda3: PublicKey;
    let syndicateUsdcPda3: PublicKey;
    const month = new BN(202501);
    let warsPda: PublicKey;
    let warsPrizePda: PublicKey;

    before(async () => {
      [syndicatePda3] = PublicKey.findProgramAddressSync(
        [
          SYNDICATE_SEED,
          player1.publicKey.toBuffer(),
          syndicateId3.toArrayLike(Buffer, "le", 8),
        ],
        programId,
      );

      [syndicateUsdcPda3] = PublicKey.findProgramAddressSync(
        [SYNDICATE_SEED, Buffer.from("usdc"), syndicatePda3.toBuffer()],
        programId,
      );

      [warsPda] = PublicKey.findProgramAddressSync(
        [SYNDICATE_WARS_SEED, month.toArrayLike(Buffer, "le", 8)],
        programId,
      );

      [warsPrizePda] = PublicKey.findProgramAddressSync(
        [
          SYNDICATE_WARS_SEED,
          Buffer.from("prize_pool"),
          month.toArrayLike(Buffer, "le", 8),
        ],
        programId,
      );
    });

    it("initializes Syndicate Wars competition", async () => {
      const now = Math.floor(Date.now() / 1000);
      const startTimestamp = new BN(now + 10); // starts in 10 seconds
      const endTimestamp = new BN(now + 86400); // ends in 24 hours

      await program.methods
        .initializeSyndicateWars({
          month: month,
          startTimestamp: startTimestamp,
          endTimestamp: endTimestamp,
          minTickets: new BN(1000),
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: pdas.lotteryState,
          syndicateWarsState: warsPda,
          prizePoolUsdc: pdas.prizePoolUsdc,
          warsPrizePoolUsdc: warsPrizePda,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      const state = await programAccounts.syndicateWarsState.fetch(warsPda);
      expect(state.month.toNumber()).to.equal(202501);
      expect(state.isActive).to.be.true;
      expect(state.registeredCount).to.equal(0);
      expect(state.minTickets.toNumber()).to.equal(1000);
    });

    it("fails to initialize Syndicate Wars from non-authority", async () => {
      const month2 = new BN(202502);
      const [warsPda2] = PublicKey.findProgramAddressSync(
        [SYNDICATE_WARS_SEED, month2.toArrayLike(Buffer, "le", 8)],
        programId,
      );
      const [warsPrizePda2] = PublicKey.findProgramAddressSync(
        [
          SYNDICATE_WARS_SEED,
          Buffer.from("prize_pool"),
          month2.toArrayLike(Buffer, "le", 8),
        ],
        programId,
      );

      const now = Math.floor(Date.now() / 1000);
      try {
        await program.methods
          .initializeSyndicateWars({
            month: month2,
            startTimestamp: new BN(now + 10),
            endTimestamp: new BN(now + 86400),
            minTickets: new BN(1000),
          })
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
            syndicateWarsState: warsPda2,
            prizePoolUsdc: pdas.prizePoolUsdc,
            warsPrizePoolUsdc: warsPrizePda2,
            usdcMint: usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — not authority");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to register syndicate with < 5 members", async () => {
      // Create a small syndicate (only 1 member = creator)
      await program.methods
        .createSyndicate({
          syndicateId: syndicateId3,
          name: "Small Syndicate",
          isPublic: true,
          managerFeeBps: 100,
        })
        .accountsPartial({
          creator: player1.publicKey,
          syndicate: syndicatePda3,
          syndicateUsdc: syndicateUsdcPda3,
          usdcMint: usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      // Wait for the competition start time
      await sleep(12000);

      const [entryPda] = PublicKey.findProgramAddressSync(
        [
          SYNDICATE_WARS_SEED,
          Buffer.from("entry"),
          month.toArrayLike(Buffer, "le", 8),
          syndicatePda3.toBuffer(),
        ],
        programId,
      );

      // Try to register — syndicate has only 1 member (needs 5)
      try {
        await program.methods
          .registerForSyndicateWars()
          .accountsPartial({
            manager: player1.publicKey,
            syndicate: syndicatePda3,
            syndicateWarsState: warsPda,
            warsEntry: entryPda,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — less than 5 members");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to finalize Syndicate Wars before end time", async () => {
      try {
        await program.methods
          .finalizeSyndicateWars()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            syndicateWarsState: warsPda,
          })
          .rpc();
        expect.fail("Should have thrown — competition not ended");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("Syndicate Wars state is consistent", async () => {
      const state = await programAccounts.syndicateWarsState.fetch(warsPda);
      expect(state.isActive).to.be.true;
      expect(state.isDistributed).to.be.false;
      expect(state.registeredCount).to.equal(0);
      expect(state.prizePool.toNumber()).to.be.greaterThanOrEqual(0);
    });
  });

  // ========================================================================
  // 27. RECLAIM EXPIRED PRIZES (edge cases)
  // ========================================================================
  describe("Reclaim Expired Prizes", () => {
    it("fails to reclaim when no draw result exists", async () => {
      // Draw ID 999 should not exist
      const [drawResultPda] = deriveDrawResultPDA(programId, 999);

      try {
        await program.methods
          .reclaimExpiredPrizes({
            drawId: new BN(999),
            amount: new BN(1000),
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: pdas.lotteryState,
            drawResult: drawResultPda,
          })
          .rpc();
        expect.fail("Should have thrown — draw result does not exist");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to reclaim from non-authority", async () => {
      const [drawResultPda] = deriveDrawResultPDA(programId, 0);

      try {
        await program.methods
          .reclaimExpiredPrizes({
            drawId: new BN(0),
            amount: new BN(1000),
          })
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: pdas.lotteryState,
            drawResult: drawResultPda,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — not authority");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ========================================================================
  // 28. CROSS-PROGRAM STATE CONSISTENCY
  // ========================================================================
  describe("Cross-Program State Consistency", () => {
    it("all internal balances match on-chain token accounts (tolerance check)", async () => {
      const state = await program.account.lotteryState.fetch(pdas.lotteryState);

      const prizePool = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      const insurance = await getAccount(
        provider.connection,
        pdas.insurancePoolUsdc,
      );
      const houseFee = await getAccount(provider.connection, pdas.houseFeeUsdc);

      // Prize pool should hold jackpot + reserve
      const expectedPrizePool =
        state.jackpotBalance.toNumber() + state.reserveBalance.toNumber();
      const tolerance = 100; // 100 lamports tolerance for rounding dust

      expect(Number(prizePool.amount) + tolerance).to.be.greaterThanOrEqual(
        expectedPrizePool,
      );

      // Insurance balance check
      expect(Number(insurance.amount) + tolerance).to.be.greaterThanOrEqual(
        state.insuranceBalance.toNumber(),
      );

      // House fee should be non-negative
      expect(Number(houseFee.amount)).to.be.greaterThanOrEqual(0);

      // All internal balances should be non-negative
      expect(state.jackpotBalance.toNumber()).to.be.greaterThanOrEqual(0);
      expect(state.reserveBalance.toNumber()).to.be.greaterThanOrEqual(0);
      expect(state.insuranceBalance.toNumber()).to.be.greaterThanOrEqual(0);
    });

    it("total tickets sold equals sum of draws", async () => {
      const state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.totalTicketsSold.toNumber()).to.be.greaterThan(0);
      expect(state.currentDrawTickets.toNumber()).to.be.lessThanOrEqual(
        state.totalTicketsSold.toNumber(),
      );
    });

    it("draw interval is within valid range", async () => {
      const state = await program.account.lotteryState.fetch(pdas.lotteryState);
      const interval = state.drawInterval.toNumber();
      expect(interval).to.be.greaterThanOrEqual(3600); // min 1 hour
      expect(interval).to.be.lessThanOrEqual(604800); // max 7 days
    });

    it("house fee bps is within valid range", async () => {
      const state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.houseFeeBps).to.be.greaterThanOrEqual(0);
      expect(state.houseFeeBps).to.be.lessThanOrEqual(5000); // max 50%
    });

    it("caps are correctly ordered (seed < soft < hard)", async () => {
      const state = await program.account.lotteryState.fetch(pdas.lotteryState);
      expect(state.seedAmount.toNumber()).to.be.lessThan(
        state.softCap.toNumber(),
      );
      expect(state.softCap.toNumber()).to.be.lessThan(state.hardCap.toNumber());
    });
  });

  // ========================================================================
  // 29. FINAL STATE SNAPSHOT
  // ========================================================================
  describe("Final State Snapshot", () => {
    it("prints final lottery state for audit", async () => {
      const state = await program.account.lotteryState.fetch(pdas.lotteryState);
      const prizePool = await getAccount(
        provider.connection,
        pdas.prizePoolUsdc,
      );
      const houseFee = await getAccount(provider.connection, pdas.houseFeeUsdc);
      const insurance = await getAccount(
        provider.connection,
        pdas.insurancePoolUsdc,
      );

      console.log("\n========== FINAL LOTTERY STATE ==========");
      console.log(`Authority: ${state.authority.toString()}`);
      console.log(`Current Draw ID: ${state.currentDrawId.toString()}`);
      console.log(
        `Jackpot Balance: ${state.jackpotBalance.toString()} (${(
          state.jackpotBalance.toNumber() / 1_000_000
        ).toFixed(2)} USDC)`,
      );
      console.log(
        `Reserve Balance: ${state.reserveBalance.toString()} (${(
          state.reserveBalance.toNumber() / 1_000_000
        ).toFixed(2)} USDC)`,
      );
      console.log(
        `Insurance Balance: ${state.insuranceBalance.toString()} (${(
          state.insuranceBalance.toNumber() / 1_000_000
        ).toFixed(2)} USDC)`,
      );
      console.log(`Total Tickets Sold: ${state.totalTicketsSold.toString()}`);
      console.log(
        `Current Draw Tickets: ${state.currentDrawTickets.toString()}`,
      );
      console.log(`Is Paused: ${state.isPaused}`);
      console.log(`Is Funded: ${state.isFunded}`);
      console.log(`Is Draw In Progress: ${state.isDrawInProgress}`);
      console.log(`Is Rolldown Active: ${state.isRolldownActive}`);
      console.log(`House Fee BPS: ${state.houseFeeBps}`);
      console.log(`Draw Interval: ${state.drawInterval.toString()}s`);
      console.log(
        `Prize Pool USDC: ${prizePool.amount.toString()} (${(
          Number(prizePool.amount) / 1_000_000
        ).toFixed(2)} USDC)`,
      );
      console.log(
        `House Fee USDC: ${houseFee.amount.toString()} (${(
          Number(houseFee.amount) / 1_000_000
        ).toFixed(2)} USDC)`,
      );
      console.log(
        `Insurance USDC: ${insurance.amount.toString()} (${(
          Number(insurance.amount) / 1_000_000
        ).toFixed(2)} USDC)`,
      );
      console.log("==========================================\n");
    });
  });
});
