import * as anchor from "@coral-xyz/anchor";
import { type Program, AnchorError, BN } from "@coral-xyz/anchor";
import {
  createAccount,
  createMint,
  getAccount,
  mintTo,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
} from "@solana/web3.js";
import { expect } from "chai";

// Import IDL types — generated by `anchor build`
import type { SolanaLotto } from "../target/types/solana_lotto";
import type { Quickpick as QuickpickIDL } from "../target/types/quickpick";

// ============================================================================
// CONSTANTS (must mirror on-chain constants)
// ============================================================================

// ---- shared seeds (used by both programs) ----
const LOTTERY_SEED = Buffer.from("lottery");
const USER_SEED = Buffer.from("user");

// ---- main-lottery-specific seeds ----
const MAIN_PRIZE_POOL_USDC_SEED = Buffer.from("prize_pool_usdc");
const MAIN_HOUSE_FEE_USDC_SEED = Buffer.from("house_fee_usdc");
const MAIN_INSURANCE_POOL_USDC_SEED = Buffer.from("insurance_pool_usdc");
const TICKET_SEED = Buffer.from("ticket");

// ---- quick-pick seeds ----
const QUICK_PICK_SEED = Buffer.from("quick_pick");
const QP_PRIZE_POOL_USDC_SEED = Buffer.from("prize_pool_usdc");
const QP_HOUSE_FEE_USDC_SEED = Buffer.from("house_fee_usdc");
const QP_INSURANCE_POOL_USDC_SEED = Buffer.from("insurance_pool_usdc");
const QUICK_PICK_TICKET_SEED = Buffer.from("quick_pick_ticket");
const QUICK_PICK_DRAW_SEED = Buffer.from("quick_pick_draw");

// ---- main lottery params ----
const MAIN_TICKET_PRICE = new BN(2_500_000); // $2.50
const MAIN_SEED_AMOUNT = new BN(500_000_000_000); // $500,000
const MAIN_SOFT_CAP = new BN(1_750_000_000_000);
const MAIN_HARD_CAP = new BN(2_250_000_000_000);
const MAIN_JACKPOT_CAP = new BN(1_750_000_000_000);
const MAIN_DRAW_INTERVAL = new BN(86400);
const MAIN_HOUSE_FEE_BPS = 2800;

// ---- quick-pick params ----
const QP_TICKET_PRICE = new BN(1_500_000); // $1.50
const QP_SEED_AMOUNT = new BN(5_000_000_000); // $5,000
const QP_SOFT_CAP = new BN(30_000_000_000); // $30,000
const QP_HARD_CAP = new BN(50_000_000_000); // $50,000
const QP_MIN_SPEND_GATE = new BN(50_000_000); // $50

const USDC_DECIMALS = 6;

// ============================================================================
// HELPER: PDA derivation
// ============================================================================

function deriveMainLotteryPDAs(programId: PublicKey) {
  const [lotteryState] = PublicKey.findProgramAddressSync(
    [LOTTERY_SEED],
    programId,
  );
  const [prizePoolUsdc] = PublicKey.findProgramAddressSync(
    [MAIN_PRIZE_POOL_USDC_SEED],
    programId,
  );
  const [houseFeeUsdc] = PublicKey.findProgramAddressSync(
    [MAIN_HOUSE_FEE_USDC_SEED],
    programId,
  );
  const [insurancePoolUsdc] = PublicKey.findProgramAddressSync(
    [MAIN_INSURANCE_POOL_USDC_SEED],
    programId,
  );
  return { lotteryState, prizePoolUsdc, houseFeeUsdc, insurancePoolUsdc };
}

function deriveQuickPickPDAs(programId: PublicKey) {
  const [quickPickState] = PublicKey.findProgramAddressSync(
    [QUICK_PICK_SEED],
    programId,
  );
  const [prizePoolUsdc] = PublicKey.findProgramAddressSync(
    [QP_PRIZE_POOL_USDC_SEED],
    programId,
  );
  const [houseFeeUsdc] = PublicKey.findProgramAddressSync(
    [QP_HOUSE_FEE_USDC_SEED],
    programId,
  );
  const [insurancePoolUsdc] = PublicKey.findProgramAddressSync(
    [QP_INSURANCE_POOL_USDC_SEED],
    programId,
  );
  return { quickPickState, prizePoolUsdc, houseFeeUsdc, insurancePoolUsdc };
}

function deriveMainTicketPDA(
  programId: PublicKey,
  drawId: number,
  ticketIndex: number,
) {
  return PublicKey.findProgramAddressSync(
    [
      TICKET_SEED,
      new BN(drawId).toArrayLike(Buffer, "le", 8),
      new BN(ticketIndex).toArrayLike(Buffer, "le", 8),
    ],
    programId,
  );
}

function deriveUserStatsPDA(programId: PublicKey, wallet: PublicKey) {
  return PublicKey.findProgramAddressSync(
    [USER_SEED, wallet.toBuffer()],
    programId,
  );
}

function deriveQPTicketPDA(
  programId: PublicKey,
  drawId: number,
  ticketIndex: number,
) {
  return PublicKey.findProgramAddressSync(
    [
      QUICK_PICK_TICKET_SEED,
      new BN(drawId).toArrayLike(Buffer, "le", 8),
      new BN(ticketIndex).toArrayLike(Buffer, "le", 8),
    ],
    programId,
  );
}

function deriveQPDrawResultPDA(programId: PublicKey, drawId: number) {
  return PublicKey.findProgramAddressSync(
    [QUICK_PICK_DRAW_SEED, new BN(drawId).toArrayLike(Buffer, "le", 8)],
    programId,
  );
}

// ============================================================================
// HELPER: token utilities
// ============================================================================

async function createUsdcMint(
  provider: anchor.AnchorProvider,
  authority: Keypair,
): Promise<PublicKey> {
  return await createMint(
    provider.connection,
    authority,
    authority.publicKey,
    null,
    USDC_DECIMALS,
  );
}

async function createAndFundUsdc(
  provider: anchor.AnchorProvider,
  mint: PublicKey,
  owner: PublicKey,
  mintAuthority: Keypair,
  amount: bigint,
): Promise<PublicKey> {
  const account = await createAccount(
    provider.connection,
    mintAuthority,
    mint,
    owner,
  );
  if (amount > 0n) {
    await mintTo(
      provider.connection,
      mintAuthority,
      mint,
      account,
      mintAuthority,
      amount,
    );
  }
  return account;
}

async function airdrop(
  provider: anchor.AnchorProvider,
  to: PublicKey,
  lamports = 100 * LAMPORTS_PER_SOL,
) {
  const sig = await provider.connection.requestAirdrop(to, lamports);
  await provider.connection.confirmTransaction(sig, "confirmed");
}

// ============================================================================
// TEST SUITE
// ============================================================================

describe("quickpick", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  // Both programs live in the same workspace
  const mainProgram = anchor.workspace.mazelprotocol as Program<SolanaLotto>;
  const qpProgram = anchor.workspace.quickpick as Program<QuickpickIDL>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const mainProgramAccounts: any = mainProgram.account;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const qpProgramAccounts: any = qpProgram.account;

  const mainProgramId = mainProgram.programId;
  const qpProgramId = qpProgram.programId;

  const authority = (provider.wallet as anchor.Wallet).payer;
  let player1: Keypair; // will have > $50 spend in main lottery
  let player2: Keypair; // will NOT meet $50 gate
  let unauthorizedUser: Keypair;

  let usdcMint: PublicKey;
  let authorityUsdc: PublicKey;
  let player1Usdc: PublicKey;
  let player2Usdc: PublicKey;
  let destinationUsdc: PublicKey;

  let mainPDAs: ReturnType<typeof deriveMainLotteryPDAs>;
  let qpPDAs: ReturnType<typeof deriveQuickPickPDAs>;

  const switchboardQueue = Keypair.generate().publicKey;

  // --------------------------------------------------------------------------
  // SETUP – initialise and fund main lottery so we can meet the $50 gate
  // --------------------------------------------------------------------------
  before(async () => {
    player1 = Keypair.generate();
    player2 = Keypair.generate();
    unauthorizedUser = Keypair.generate();

    await Promise.all([
      airdrop(provider, player1.publicKey),
      airdrop(provider, player2.publicKey),
      airdrop(provider, unauthorizedUser.publicKey),
    ]);

    usdcMint = await createUsdcMint(provider, authority);

    mainPDAs = deriveMainLotteryPDAs(mainProgramId);
    qpPDAs = deriveQuickPickPDAs(qpProgramId);

    // Authority needs USDC for seeding both lotteries
    const totalAuthorityUsdc =
      BigInt(MAIN_SEED_AMOUNT.toString()) +
      BigInt(QP_SEED_AMOUNT.toString()) +
      BigInt(50_000_000_000); // extra
    authorityUsdc = await createAndFundUsdc(
      provider,
      usdcMint,
      authority.publicKey,
      authority,
      totalAuthorityUsdc,
    );

    // Player1 gets a generous USDC balance for main + QP tickets
    player1Usdc = await createAndFundUsdc(
      provider,
      usdcMint,
      player1.publicKey,
      authority,
      BigInt(10_000_000_000), // $10,000
    );

    // Player2 gets a small balance (NOT enough to pass $50 gate via main lottery)
    player2Usdc = await createAndFundUsdc(
      provider,
      usdcMint,
      player2.publicKey,
      authority,
      BigInt(1_000_000_000), // $1,000
    );

    destinationUsdc = await createAndFundUsdc(
      provider,
      usdcMint,
      authority.publicKey,
      authority,
      0n,
    );

    // ---------------------------------------------------------------
    // Initialise + fund the MAIN lottery (needed for authority checks
    // and the $50 spend-gate UserStats account).
    // ---------------------------------------------------------------
    await mainProgram.methods
      .initialize({
        ticketPrice: MAIN_TICKET_PRICE,
        houseFeeBps: MAIN_HOUSE_FEE_BPS,
        jackpotCap: MAIN_JACKPOT_CAP,
        seedAmount: MAIN_SEED_AMOUNT,
        softCap: MAIN_SOFT_CAP,
        hardCap: MAIN_HARD_CAP,
        drawInterval: MAIN_DRAW_INTERVAL,
        switchboardQueue,
      })
      .accountsPartial({
        authority: authority.publicKey,
        lotteryState: mainPDAs.lotteryState,
        usdcMint,
        prizePoolUsdc: mainPDAs.prizePoolUsdc,
        houseFeeUsdc: mainPDAs.houseFeeUsdc,
        insurancePoolUsdc: mainPDAs.insurancePoolUsdc,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .rpc();

    await mainProgram.methods
      .fundSeed()
      .accountsPartial({
        authority: authority.publicKey,
        lotteryState: mainPDAs.lotteryState,
        authorityUsdc,
        prizePoolUsdc: mainPDAs.prizePoolUsdc,
        usdcMint,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    // ---------------------------------------------------------------
    // Have player1 buy enough main-lottery tickets to exceed $50 gate
    // $2.50 per ticket × 21 tickets = $52.50 > $50
    // ---------------------------------------------------------------
    const ticketsToBuy = 21;
    for (let i = 0; i < ticketsToBuy; i++) {
      const mainState = await mainProgramAccounts.lotteryState.fetch(
        mainPDAs.lotteryState,
      );
      const drawId = mainState.currentDrawId.toNumber();
      const idx = mainState.currentDrawTickets.toNumber();
      const [ticketPda] = deriveMainTicketPDA(mainProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      // Generate unique valid numbers for each ticket
      const base = (i * 6) % 40;
      const numbers = [
        base + 1,
        base + 2,
        base + 3,
        base + 4,
        base + 5,
        base + 6,
      ].map((n) => Math.min(n, 46)) as [
        number,
        number,
        number,
        number,
        number,
        number,
      ];
      // Ensure uniqueness
      const unique = Array.from(new Set(numbers));
      while (unique.length < 6) unique.push(unique.length + 40);
      const finalNums = unique.slice(0, 6).sort((a, b) => a - b) as [
        number,
        number,
        number,
        number,
        number,
        number,
      ];

      await mainProgram.methods
        .buyTicket({ numbers: finalNums, useFreeTicket: false })
        .accountsPartial({
          player: player1.publicKey,
          lotteryState: mainPDAs.lotteryState,
          ticket: ticketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: mainPDAs.prizePoolUsdc,
          houseFeeUsdc: mainPDAs.houseFeeUsdc,
          insurancePoolUsdc: mainPDAs.insurancePoolUsdc,
          usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();
    }

    // Confirm the gate is met
    const [userStatsPda] = deriveUserStatsPDA(mainProgramId, player1.publicKey);
    const stats = await mainProgramAccounts.userStats.fetch(userStatsPda);
    expect(stats.totalSpent.toNumber()).to.be.greaterThanOrEqual(
      QP_MIN_SPEND_GATE.toNumber(),
    );
  });

  // ==========================================================================
  // 1. INITIALIZE QUICK PICK
  // ==========================================================================
  describe("Initialize Quick Pick", () => {
    it("initializes Quick Pick Express successfully", async () => {
      await qpProgram.methods
        .initialize({ firstDrawTimestamp: null })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
          usdcMint,
          prizePoolUsdc: qpPDAs.prizePoolUsdc,
          houseFeeUsdc: qpPDAs.houseFeeUsdc,
          insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        })
        .rpc();

      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );

      expect(state.currentDraw.toNumber()).to.equal(1);
      expect(state.ticketPrice.toString()).to.equal(QP_TICKET_PRICE.toString());
      expect(state.pickCount).to.equal(5);
      expect(state.numberRange).to.equal(35);
      expect(state.softCap.toString()).to.equal(QP_SOFT_CAP.toString());
      expect(state.hardCap.toString()).to.equal(QP_HARD_CAP.toString());
      expect(state.seedAmount.toString()).to.equal(QP_SEED_AMOUNT.toString());
      expect(state.jackpotBalance.toNumber()).to.equal(0);
      expect(state.prizePoolBalance.toNumber()).to.equal(0);
      expect(state.insuranceBalance.toNumber()).to.equal(0);
      expect(state.currentDrawTickets.toNumber()).to.equal(0);
      expect(state.totalTicketsSold.toNumber()).to.equal(0);
      expect(state.isPaused).to.be.true;
      expect(state.isFunded).to.be.false;
      expect(state.isDrawInProgress).to.be.false;
      expect(state.isRolldownPending).to.be.false;
    });

    it("fails to initialize a second time", async () => {
      try {
        await qpProgram.methods
          .initialize({ firstDrawTimestamp: null })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            usdcMint,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            systemProgram: SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          })
          .rpc();
        expect.fail("Should have thrown — account already exists");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to initialize from non-authority", async () => {
      // The PDA already exists so this would fail anyway, but it validates
      // the constraint check path.
      try {
        await qpProgram.methods
          .initialize({ firstDrawTimestamp: null })
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            usdcMint,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            systemProgram: SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ==========================================================================
  // 2. FUND SEED
  // ==========================================================================
  describe("Fund Seed", () => {
    it("fails to buy tickets before funding (paused)", async () => {
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, 1, 0);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [1, 10, 20, 30, 35] })
          .accountsPartial({
            player: player1.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — paused");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("fails to fund seed from non-authority", async () => {
      const unAuthUsdc = await createAndFundUsdc(
        provider,
        usdcMint,
        unauthorizedUser.publicKey,
        authority,
        BigInt(QP_SEED_AMOUNT.toString()),
      );

      try {
        await qpProgram.methods
          .fundSeed()
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            authorityUsdc: unAuthUsdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("funds the seed successfully", async () => {
      await qpProgram.methods
        .fundSeed()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
          authorityUsdc: authorityUsdc,
          prizePoolUsdc: qpPDAs.prizePoolUsdc,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();

      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.jackpotBalance.toString()).to.equal(
        QP_SEED_AMOUNT.toString(),
      );
      expect(state.isFunded).to.be.true;
      expect(state.isPaused).to.be.false;

      // Verify USDC transferred
      const pool = await getAccount(provider.connection, qpPDAs.prizePoolUsdc);
      expect(Number(pool.amount)).to.equal(Number(QP_SEED_AMOUNT.toString()));
    });

    it("fails to fund seed a second time", async () => {
      try {
        await qpProgram.methods
          .fundSeed()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            authorityUsdc: authorityUsdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — already funded");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("AlreadyInitialized");
        }
      }
    });
  });

  // ==========================================================================
  // 3. PAUSE / UNPAUSE
  // ==========================================================================
  describe("Pause / Unpause", () => {
    it("pauses Quick Pick", async () => {
      await qpProgram.methods
        .pause("QP maintenance")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.isPaused).to.be.true;
    });

    it("fails to pause from non-authority", async () => {
      try {
        await qpProgram.methods
          .pause("hack")
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("unpauses Quick Pick", async () => {
      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.isPaused).to.be.false;
    });

    it("fails to unpause from non-authority", async () => {
      // Pause first
      await qpProgram.methods
        .pause("test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      try {
        await qpProgram.methods
          .unpause()
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Cleanup – unpause
      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });
  });

  // ==========================================================================
  // 4. BUY TICKET — success & $50 gate
  // ==========================================================================
  describe("Buy Ticket", () => {
    it("player1 buys a Quick Pick ticket (gate met)", async () => {
      const stateBefore = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = stateBefore.currentDraw.toNumber();
      const ticketIdx = stateBefore.currentDrawTickets.toNumber();

      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, ticketIdx);
      // UserStats is owned by the main program
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      const playerUsdcBefore = await getAccount(
        provider.connection,
        player1Usdc,
      );

      await qpProgram.methods
        .buyTicket({ numbers: [3, 12, 20, 28, 35] })
        .accountsPartial({
          player: player1.publicKey,
          quickPickState: qpPDAs.quickPickState,
          ticket: ticketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: qpPDAs.prizePoolUsdc,
          houseFeeUsdc: qpPDAs.houseFeeUsdc,
          insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
          usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      // Verify ticket created
      const ticket = await qpProgramAccounts.quickPickTicket.fetch(ticketPda);
      expect(ticket.owner.toString()).to.equal(player1.publicKey.toString());
      expect(ticket.drawId.toNumber()).to.equal(drawId);
      expect(ticket.numbers).to.deep.equal([3, 12, 20, 28, 35]);
      expect(ticket.isClaimed).to.be.false;
      expect(ticket.matchCount).to.equal(0);
      expect(ticket.prizeAmount.toNumber()).to.equal(0);

      // Verify USDC deducted
      const playerUsdcAfter = await getAccount(
        provider.connection,
        player1Usdc,
      );
      expect(
        Number(playerUsdcBefore.amount) - Number(playerUsdcAfter.amount),
      ).to.equal(QP_TICKET_PRICE.toNumber());

      // Verify state updated
      const stateAfter = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(stateAfter.currentDrawTickets.toNumber()).to.equal(ticketIdx + 1);
      expect(stateAfter.totalTicketsSold.toNumber()).to.equal(
        stateBefore.totalTicketsSold.toNumber() + 1,
      );
    });

    it("buys ticket with unsorted numbers (stored sorted)", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      await qpProgram.methods
        .buyTicket({ numbers: [35, 1, 20, 10, 5] })
        .accountsPartial({
          player: player1.publicKey,
          quickPickState: qpPDAs.quickPickState,
          ticket: ticketPda,
          playerUsdc: player1Usdc,
          prizePoolUsdc: qpPDAs.prizePoolUsdc,
          houseFeeUsdc: qpPDAs.houseFeeUsdc,
          insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
          usdcMint,
          userStats: userStatsPda,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .signers([player1])
        .rpc();

      const ticket = await qpProgramAccounts.quickPickTicket.fetch(ticketPda);
      expect(ticket.numbers).to.deep.equal([1, 5, 10, 20, 35]);
    });

    it("fails for player2 who has NOT met the $50 gate", async () => {
      // player2 has UserStats that either doesn't exist or has totalSpent < $50
      // Because the UserStats PDA is derived from the *main* program id,
      // if the account doesn't exist the QP program's constraint check will
      // fail (account not initialised). If it exists but total_spent < $50 it
      // will fail with InsufficientMainLotterySpend.
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player2.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [1, 5, 10, 20, 30] })
          .accountsPartial({
            player: player2.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player2Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player2])
          .rpc();
        expect.fail("Should have thrown — $50 gate not met");
      } catch (err: unknown) {
        expect(err).to.exist;
        // Either AccountNotInitialized (no UserStats) or
        // InsufficientMainLotterySpend (UserStats exists but spend < $50)
      }
    });
  });

  // ==========================================================================
  // 5. BUY TICKET — invalid numbers
  // ==========================================================================
  describe("Buy Ticket – Invalid Numbers", () => {
    it("fails with number 0 (out of range)", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [0, 5, 10, 20, 30] })
          .accountsPartial({
            player: player1.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — 0 out of range");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("NumbersOutOfRange");
        }
      }
    });

    it("fails with number 36 (out of range for 5/35)", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [1, 5, 10, 20, 36] })
          .accountsPartial({
            player: player1.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — 36 out of range");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("NumbersOutOfRange");
        }
      }
    });

    it("fails with duplicate numbers", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [5, 5, 10, 20, 30] })
          .accountsPartial({
            player: player1.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — duplicate numbers");
      } catch (err: unknown) {
        expect(err).to.exist;
        if (err instanceof AnchorError) {
          expect(err.error.errorCode.code).to.equal("DuplicateNumbers");
        }
      }
    });

    it("fails with all-same numbers", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [15, 15, 15, 15, 15] })
          .accountsPartial({
            player: player1.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
        expect.fail("Should have thrown — all duplicates");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ==========================================================================
  // 6. BUY TICKET — insufficient USDC
  // ==========================================================================
  describe("Buy Ticket – Insufficient Funds", () => {
    it("fails when player has no USDC", async () => {
      // Create a user who HAS met the gate (reuse player1's UserStats trick
      // won't work for a fresh keypair). Instead, just expect this to fail
      // either on the gate check or the funds check.
      const brokePlayer = Keypair.generate();
      await airdrop(provider, brokePlayer.publicKey);
      const brokeUsdc = await createAndFundUsdc(
        provider,
        usdcMint,
        brokePlayer.publicKey,
        authority,
        0n,
      );

      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const idx = state.currentDrawTickets.toNumber();
      const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        brokePlayer.publicKey,
      );

      try {
        await qpProgram.methods
          .buyTicket({ numbers: [1, 10, 20, 30, 35] })
          .accountsPartial({
            player: brokePlayer.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: brokeUsdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([brokePlayer])
          .rpc();
        expect.fail("Should have thrown");
      } catch (err: unknown) {
        expect(err).to.exist;
        // Might fail on gate or funds – either is acceptable
      }
    });
  });

  // ==========================================================================
  // 7. FUND DISTRIBUTION VERIFICATION
  // ==========================================================================
  describe("Fund Distribution", () => {
    it("verifies USDC split across QP pools after ticket purchases", async () => {
      const pool = await getAccount(provider.connection, qpPDAs.prizePoolUsdc);
      const house = await getAccount(provider.connection, qpPDAs.houseFeeUsdc);
      const insurance = await getAccount(
        provider.connection,
        qpPDAs.insurancePoolUsdc,
      );

      // Prize pool = seed + ticket contributions
      expect(Number(pool.amount)).to.be.greaterThan(
        Number(QP_SEED_AMOUNT.toString()),
      );

      // House fee accumulated
      expect(Number(house.amount)).to.be.greaterThan(0);

      // Insurance accumulated
      expect(Number(insurance.amount)).to.be.greaterThan(0);

      // Total USDC out of players = ticket_price × numTickets
      // 2 tickets purchased by player1 in the BuyTicket tests
      const numTickets = 2;
      const totalRevenue = QP_TICKET_PRICE.toNumber() * numTickets;
      const totalInPools =
        Number(pool.amount) -
        Number(QP_SEED_AMOUNT.toString()) +
        Number(house.amount) +
        Number(insurance.amount);
      expect(totalInPools).to.equal(totalRevenue);
    });
  });

  // ==========================================================================
  // 8. UPDATE CONFIG
  // ==========================================================================
  describe("Update Config", () => {
    it("updates ticket price via config", async () => {
      await qpProgram.methods
        .pause("config")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      const newPrice = new BN(2_000_000); // $2
      await qpProgram.methods
        .updateConfig({
          ticketPrice: newPrice,
          softCap: null,
          hardCap: null,
          seedAmount: null,
          drawInterval: null,
          match4Prize: null,
          match3Prize: null,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.ticketPrice.toString()).to.equal(newPrice.toString());

      // Restore original price
      await qpProgram.methods
        .updateConfig({
          ticketPrice: QP_TICKET_PRICE,
          softCap: null,
          hardCap: null,
          seedAmount: null,
          drawInterval: null,
          match4Prize: null,
          match3Prize: null,
        })
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });

    it("fails to update config from non-authority", async () => {
      try {
        await qpProgram.methods
          .updateConfig({
            ticketPrice: new BN(100),
            softCap: null,
            hardCap: null,
            seedAmount: null,
            drawInterval: null,
            match4Prize: null,
            match3Prize: null,
          })
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ==========================================================================
  // 9. WITHDRAW HOUSE FEES
  // ==========================================================================
  describe("Withdraw House Fees", () => {
    it("withdraws accumulated QP house fees", async () => {
      const houseAccount = await getAccount(
        provider.connection,
        qpPDAs.houseFeeUsdc,
      );
      const balance = Number(houseAccount.amount);

      if (balance > 0) {
        const destBefore = await getAccount(
          provider.connection,
          destinationUsdc,
        );

        await qpProgram.methods
          .withdrawHouseFees(new BN(balance))
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();

        const houseAfter = await getAccount(
          provider.connection,
          qpPDAs.houseFeeUsdc,
        );
        expect(Number(houseAfter.amount)).to.equal(0);

        const destAfter = await getAccount(
          provider.connection,
          destinationUsdc,
        );
        expect(Number(destAfter.amount) - Number(destBefore.amount)).to.equal(
          balance,
        );
      }
    });

    it("fails to withdraw from non-authority", async () => {
      try {
        await qpProgram.methods
          .withdrawHouseFees(new BN(1))
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            destinationUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ==========================================================================
  // 10. ADD RESERVE FUNDS
  // ==========================================================================
  describe("Add Reserve Funds", () => {
    it("adds reserve funds", async () => {
      const stateBefore = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const reserveBefore = stateBefore.reserveBalance.toNumber();

      const addAmount = new BN(1_000_000_000); // $1,000
      await qpProgram.methods
        .addReserveFunds(addAmount)
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
          authorityUsdc,
          prizePoolUsdc: qpPDAs.prizePoolUsdc,
          usdcMint,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();

      const stateAfter = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(stateAfter.reserveBalance.toNumber()).to.equal(
        reserveBefore + addAmount.toNumber(),
      );
    });
  });

  // ==========================================================================
  // 11. CANCEL / FORCE-FINALIZE DRAW
  // ==========================================================================
  describe("Cancel / Force-Finalize Draw", () => {
    it("cancel_draw fails when no draw is in progress", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.isDrawInProgress).to.be.false;

      try {
        await qpProgram.methods
          .cancelDraw("Testing")
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .rpc();
        expect.fail("Should have thrown — no draw in progress");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("force_finalize_draw fails when no draw in progress", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const drawId = state.currentDraw.toNumber();
      const [drawResultPda] = deriveQPDrawResultPDA(qpProgramId, drawId);

      try {
        await qpProgram.methods
          .forceFinalizeDraw("Testing force finalize")
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            drawResult: drawResultPda,
          })
          .rpc();
        expect.fail("Should have thrown");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("cancel_draw fails from non-authority", async () => {
      try {
        await qpProgram.methods
          .cancelDraw("Unauthorized")
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ==========================================================================
  // 12. EMERGENCY FUND TRANSFER
  // ==========================================================================
  describe("Emergency Fund Transfer", () => {
    it("fails when Quick Pick is not paused", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.isPaused).to.be.false;

      try {
        await qpProgram.methods
          .emergencyFundTransfer(
            { reserve: {} },
            new BN(1_000_000),
            "Test emergency",
          )
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            sourceUsdc: qpPDAs.prizePoolUsdc,
            destinationUsdc,
            usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — not paused");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("transfers emergency funds when paused", async () => {
      await qpProgram.methods
        .pause("Emergency test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      const stateBefore = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const reserveBefore = stateBefore.reserveBalance.toNumber();

      if (reserveBefore > 0) {
        const transferAmt = new BN(Math.min(reserveBefore, 500_000_000)); // $500 or less

        await qpProgram.methods
          .emergencyFundTransfer(
            { reserve: {} },
            transferAmt,
            "Reserve emergency",
          )
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            sourceUsdc: qpPDAs.prizePoolUsdc,
            destinationUsdc,
            usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();

        const stateAfter = await qpProgramAccounts.quickPickState.fetch(
          qpPDAs.quickPickState,
        );
        expect(stateAfter.reserveBalance.toNumber()).to.be.lessThan(
          reserveBefore,
        );
      }

      // Unpause for further tests
      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });

    it("fails from non-authority", async () => {
      await qpProgram.methods
        .pause("Auth test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      try {
        await qpProgram.methods
          .emergencyFundTransfer({ reserve: {} }, new BN(1), "Unauthorized")
          .accountsPartial({
            authority: unauthorizedUser.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            sourceUsdc: qpPDAs.prizePoolUsdc,
            destinationUsdc,
            usdcMint,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .signers([unauthorizedUser])
          .rpc();
        expect.fail("Should have thrown — unauthorized");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });
  });

  // ==========================================================================
  // 13. DRAW LIFECYCLE (requires Switchboard)
  // ==========================================================================
  describe("Draw Lifecycle (requires Switchboard)", () => {
    it("commit_randomness fails when draw time not reached", async () => {
      // next_draw_timestamp is set in the future
      const fakeRandomness = Keypair.generate();

      try {
        await qpProgram.methods
          .commitRandomness()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            randomnessAccountData: fakeRandomness.publicKey,
          })
          .rpc();
        expect.fail("Should have thrown — draw not ready");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("execute_draw fails when no draw in progress", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.isDrawInProgress).to.be.false;

      const [drawResultPda] = deriveQPDrawResultPDA(
        qpProgramId,
        state.currentDraw.toNumber(),
      );
      const fakeRandomness = Keypair.generate();

      try {
        await qpProgram.methods
          .executeDraw()
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            drawResult: drawResultPda,
            randomnessAccountData: fakeRandomness.publicKey,
            payer: authority.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .rpc();
        expect.fail("Should have thrown");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });

    it("finalize_draw fails when no draw result exists", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const [drawResultPda] = deriveQPDrawResultPDA(
        qpProgramId,
        state.currentDraw.toNumber(),
      );

      try {
        await qpProgram.methods
          .finalizeDraw({
            winnerCounts: { match5: 0, match4: 1, match3: 5 },
            verificationHash: Array(32).fill(0),
            indexerNonce: new anchor.BN(0),
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            drawResult: drawResultPda,
          })
          .rpc();
        expect.fail("Should have thrown — no draw result");
      } catch (err: unknown) {
        expect(err).to.exist;
      }
    });
  });

  // ==========================================================================
  // 14. COMPREHENSIVE ACCESS CONTROL
  // ==========================================================================
  describe("Access Control Summary", () => {
    it("unauthorized user cannot perform any QP admin action", async () => {
      const actions = [
        () =>
          qpProgram.methods
            .pause("hack")
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: mainPDAs.lotteryState,
              quickPickState: qpPDAs.quickPickState,
            })
            .signers([unauthorizedUser])
            .rpc(),
        () =>
          qpProgram.methods
            .withdrawHouseFees(new BN(1))
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: mainPDAs.lotteryState,
              quickPickState: qpPDAs.quickPickState,
              houseFeeUsdc: qpPDAs.houseFeeUsdc,
              destinationUsdc,
              tokenProgram: TOKEN_PROGRAM_ID,
            })
            .signers([unauthorizedUser])
            .rpc(),
        () =>
          qpProgram.methods
            .cancelDraw("hack")
            .accountsPartial({
              authority: unauthorizedUser.publicKey,
              lotteryState: mainPDAs.lotteryState,
              quickPickState: qpPDAs.quickPickState,
            })
            .signers([unauthorizedUser])
            .rpc(),
      ];

      for (const action of actions) {
        try {
          await action();
          expect.fail("Should have thrown — unauthorized");
        } catch (err: unknown) {
          expect(err).to.exist;
        }
      }
    });
  });

  // ==========================================================================
  // 15. STATE INVARIANTS
  // ==========================================================================
  describe("State Invariants", () => {
    it("Quick Pick state is consistent after all operations", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );

      expect(state.isFunded).to.be.true;
      expect(state.isPaused).to.be.false;
      expect(state.isDrawInProgress).to.be.false;
      expect(state.currentDraw.toNumber()).to.equal(1);
      expect(state.totalTicketsSold.toNumber()).to.be.greaterThanOrEqual(2);
      expect(state.jackpotBalance.toNumber()).to.be.greaterThanOrEqual(
        QP_SEED_AMOUNT.toNumber(),
      );
      expect(state.ticketPrice.toString()).to.equal(QP_TICKET_PRICE.toString());
      expect(state.pickCount).to.equal(5);
      expect(state.numberRange).to.equal(35);
      expect(state.softCap.toString()).to.equal(QP_SOFT_CAP.toString());
      expect(state.hardCap.toString()).to.equal(QP_HARD_CAP.toString());
    });

    it("token accounts are non-negative", async () => {
      const pool = await getAccount(provider.connection, qpPDAs.prizePoolUsdc);
      const house = await getAccount(provider.connection, qpPDAs.houseFeeUsdc);
      const insurance = await getAccount(
        provider.connection,
        qpPDAs.insurancePoolUsdc,
      );

      expect(Number(pool.amount)).to.be.greaterThanOrEqual(0);
      expect(Number(house.amount)).to.be.greaterThanOrEqual(0);
      expect(Number(insurance.amount)).to.be.greaterThanOrEqual(0);
    });
  });

  // ==========================================================================
  // 16. MULTIPLE TICKET PURCHASES
  // ==========================================================================
  describe("Multiple Ticket Purchases", () => {
    it("player1 buys several more QP tickets", async () => {
      const ticketSets: [number, number, number, number, number][] = [
        [2, 7, 14, 22, 31],
        [4, 11, 18, 25, 33],
        [6, 13, 19, 27, 34],
      ];

      for (const numbers of ticketSets) {
        const state = await qpProgramAccounts.quickPickState.fetch(
          qpPDAs.quickPickState,
        );
        const drawId = state.currentDraw.toNumber();
        const idx = state.currentDrawTickets.toNumber();
        const [ticketPda] = deriveQPTicketPDA(qpProgramId, drawId, idx);
        const [userStatsPda] = deriveUserStatsPDA(
          mainProgramId,
          player1.publicKey,
        );

        await qpProgram.methods
          .buyTicket({ numbers })
          .accountsPartial({
            player: player1.publicKey,
            quickPickState: qpPDAs.quickPickState,
            ticket: ticketPda,
            playerUsdc: player1Usdc,
            prizePoolUsdc: qpPDAs.prizePoolUsdc,
            houseFeeUsdc: qpPDAs.houseFeeUsdc,
            insurancePoolUsdc: qpPDAs.insurancePoolUsdc,
            usdcMint,
            userStats: userStatsPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
          })
          .signers([player1])
          .rpc();
      }

      const stateAfter = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      // 2 earlier + 3 new = 5
      expect(stateAfter.totalTicketsSold.toNumber()).to.be.greaterThanOrEqual(
        5,
      );
    });
  });

  // ==========================================================================
  // 17. DYNAMIC FEE TIER
  // ==========================================================================
  describe("Dynamic Fee Tier", () => {
    it("verifies house fee BPS matches current jackpot tier", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const jackpot = state.jackpotBalance.toNumber();

      // QP fee tiers:
      // < $10k:  3000 (30%)
      // $10k-$20k: 3300 (33%)
      // $20k-$30k: 3600 (36%)
      // >= $30k: 3800 (38%)
      // Rolldown: 2800 (28%)
      const t1 = 10_000_000_000;
      const t2 = 20_000_000_000;
      const t3 = 30_000_000_000;

      let expected: number;
      if (state.isRolldownPending) {
        expected = 2800;
      } else if (jackpot < t1) {
        expected = 3000;
      } else if (jackpot < t2) {
        expected = 3300;
      } else if (jackpot < t3) {
        expected = 3600;
      } else {
        expected = 3800;
      }

      expect(state.houseFeeBps).to.equal(expected);
    });
  });

  // ==========================================================================
  // 18. UPDATE CONFIG – Edge Cases
  // ==========================================================================
  describe("Update Config – Edge Cases", () => {
    it("fails to update config with invalid draw interval (< 1 hour)", async () => {
      // Pause first so config can be updated
      await qpProgram.methods
        .pause("config test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      try {
        await qpProgram.methods
          .updateConfig({
            ticketPrice: null,
            softCap: null,
            hardCap: null,
            seedAmount: null,
            drawInterval: new BN(1800), // 30 min – too short
            match4Prize: null,
            match3Prize: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .rpc();
        expect.fail("Should have thrown — draw interval too short");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Unpause
      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });

    it("fails to update config with invalid caps (soft >= hard)", async () => {
      await qpProgram.methods
        .pause("config test 2")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      try {
        await qpProgram.methods
          .updateConfig({
            ticketPrice: null,
            softCap: new BN(60_000_000_000), // $60k
            hardCap: new BN(30_000_000_000), // $30k – less than soft cap
            seedAmount: null,
            drawInterval: null,
            match4Prize: null,
            match3Prize: null,
          })
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
          })
          .rpc();
        expect.fail("Should have thrown — soft cap >= hard cap");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Unpause
      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });
  });

  // ==========================================================================
  // 19. CROSS-POOL BALANCE CONSISTENCY
  // ==========================================================================
  describe("Cross-Pool Balance Consistency", () => {
    it("all QP internal balances match on-chain token accounts", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );

      const pool = await getAccount(provider.connection, qpPDAs.prizePoolUsdc);
      const house = await getAccount(provider.connection, qpPDAs.houseFeeUsdc);
      const insurance = await getAccount(
        provider.connection,
        qpPDAs.insurancePoolUsdc,
      );

      // All on-chain balances should be non-negative
      expect(Number(pool.amount)).to.be.greaterThanOrEqual(0);
      expect(Number(house.amount)).to.be.greaterThanOrEqual(0);
      expect(Number(insurance.amount)).to.be.greaterThanOrEqual(0);

      // Internal accounting should be non-negative
      expect(state.jackpotBalance.toNumber()).to.be.greaterThanOrEqual(0);
      expect(state.prizePoolBalance.toNumber()).to.be.greaterThanOrEqual(0);
      expect(state.insuranceBalance.toNumber()).to.be.greaterThanOrEqual(0);

      // Prize pool token account should hold at least jackpot + prize_pool_balance
      const expectedMinPool = state.jackpotBalance
        .add(state.prizePoolBalance)
        .toNumber();
      const tolerance = 100; // 100 lamports for rounding dust
      expect(Number(pool.amount) + tolerance).to.be.greaterThanOrEqual(
        expectedMinPool,
      );
    });

    it("total tickets sold equals current draw tickets (single draw)", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      // With only one draw cycle, totalTicketsSold should equal or exceed currentDrawTickets
      expect(state.totalTicketsSold.toNumber()).to.be.greaterThanOrEqual(
        state.currentDrawTickets.toNumber(),
      );
    });

    it("draw interval is within valid range", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const interval = state.drawInterval.toNumber();
      expect(interval).to.be.greaterThanOrEqual(3600); // min 1 hour
      expect(interval).to.be.lessThanOrEqual(604800); // max 7 days
    });

    it("house fee BPS is within valid range", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.houseFeeBps).to.be.greaterThanOrEqual(0);
      expect(state.houseFeeBps).to.be.lessThanOrEqual(5000); // max 50%
    });

    it("caps are correctly ordered (seed < soft < hard)", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.seedAmount.toNumber()).to.be.lessThan(
        state.softCap.toNumber(),
      );
      expect(state.softCap.toNumber()).to.be.lessThan(state.hardCap.toNumber());
    });
  });

  // ==========================================================================
  // 20. MULTI-PLAYER PURCHASE TRACKING
  // ==========================================================================
  describe("Multi-Player Purchase Tracking", () => {
    it("player1 user stats reflect all QP + main purchases", async () => {
      const [userStatsPda] = deriveUserStatsPDA(
        mainProgramId,
        player1.publicKey,
      );
      const stats = await mainProgramAccounts.userStats.fetch(userStatsPda);
      // player1 bought 21+ main tickets in before() plus more during tests
      expect(stats.totalTickets.toNumber()).to.be.greaterThanOrEqual(21);
      expect(stats.totalSpent.toNumber()).to.be.greaterThanOrEqual(
        QP_MIN_SPEND_GATE.toNumber(),
      );
    });

    it("QP state tracks correct number of tickets sold", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      // We bought multiple QP tickets during the test suite
      expect(state.totalTicketsSold.toNumber()).to.be.greaterThanOrEqual(2);
      expect(state.currentDrawTickets.toNumber()).to.be.greaterThanOrEqual(2);
    });

    it("verifies ticket price has not drifted", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      // Ticket price should match original unless explicitly changed
      expect(state.ticketPrice.toNumber()).to.equal(QP_TICKET_PRICE.toNumber());
    });

    it("pick count and number range are correct", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      expect(state.pickCount).to.equal(5); // 5/35 matrix
      expect(state.numberRange).to.equal(35);
    });
  });

  // ==========================================================================
  // 21. EMERGENCY FUND TRANSFER – Additional Cases
  // ==========================================================================
  describe("Emergency Fund Transfer – Additional Cases", () => {
    it("fails with zero amount", async () => {
      // Pause QP first
      await qpProgram.methods
        .pause("emergency test")
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();

      try {
        await qpProgram.methods
          .emergencyFundTransfer(
            { reserve: {} },
            new BN(0), // zero amount
            "test zero",
          )
          .accountsPartial({
            authority: authority.publicKey,
            lotteryState: mainPDAs.lotteryState,
            quickPickState: qpPDAs.quickPickState,
            sourceUsdc: qpPDAs.prizePoolUsdc,
            tokenProgram: TOKEN_PROGRAM_ID,
          })
          .rpc();
        expect.fail("Should have thrown — zero amount");
      } catch (err: unknown) {
        expect(err).to.exist;
      }

      // Unpause
      await qpProgram.methods
        .unpause()
        .accountsPartial({
          authority: authority.publicKey,
          lotteryState: mainPDAs.lotteryState,
          quickPickState: qpPDAs.quickPickState,
        })
        .rpc();
    });
  });

  // ==========================================================================
  // 22. FINAL STATE SNAPSHOT
  // ==========================================================================
  describe("Final State Snapshot", () => {
    it("prints final Quick Pick state for audit", async () => {
      const state = await qpProgramAccounts.quickPickState.fetch(
        qpPDAs.quickPickState,
      );
      const pool = await getAccount(provider.connection, qpPDAs.prizePoolUsdc);
      const house = await getAccount(provider.connection, qpPDAs.houseFeeUsdc);
      const insurance = await getAccount(
        provider.connection,
        qpPDAs.insurancePoolUsdc,
      );

      console.log("\n========== FINAL QUICK PICK STATE ==========");
      console.log(`Current Draw: ${state.currentDraw.toString()}`);
      console.log(
        `Ticket Price: ${state.ticketPrice.toString()} ($${(state.ticketPrice.toNumber() / 1_000_000).toFixed(2)})`,
      );
      console.log(
        `Pick Count / Range: ${state.pickCount}/${state.numberRange}`,
      );
      console.log(
        `Jackpot Balance: ${state.jackpotBalance.toString()} ($${(state.jackpotBalance.toNumber() / 1_000_000).toFixed(2)})`,
      );
      console.log(
        `Prize Pool Balance: ${state.prizePoolBalance.toString()} ($${(state.prizePoolBalance.toNumber() / 1_000_000).toFixed(2)})`,
      );
      console.log(
        `Insurance Balance: ${state.insuranceBalance.toString()} ($${(state.insuranceBalance.toNumber() / 1_000_000).toFixed(2)})`,
      );
      console.log(
        `Reserve Balance: ${state.reserveBalance.toString()} ($${(state.reserveBalance.toNumber() / 1_000_000).toFixed(2)})`,
      );
      console.log(`Total Tickets Sold: ${state.totalTicketsSold.toString()}`);
      console.log(
        `Current Draw Tickets: ${state.currentDrawTickets.toString()}`,
      );
      console.log(`House Fee BPS: ${state.houseFeeBps}`);
      console.log(`Is Paused: ${state.isPaused}`);
      console.log(`Is Funded: ${state.isFunded}`);
      console.log(`Is Draw In Progress: ${state.isDrawInProgress}`);
      console.log(`Is Rolldown Pending: ${state.isRolldownPending}`);
      console.log(
        `Prize Pool USDC: ${pool.amount.toString()} ($${(Number(pool.amount) / 1_000_000).toFixed(2)})`,
      );
      console.log(
        `House Fee USDC: ${house.amount.toString()} ($${(Number(house.amount) / 1_000_000).toFixed(2)})`,
      );
      console.log(
        `Insurance USDC: ${insurance.amount.toString()} ($${(Number(insurance.amount) / 1_000_000).toFixed(2)})`,
      );
      console.log("=============================================\n");
    });
  });
});
