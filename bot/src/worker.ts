/**
 * MazelProtocol Draw Lifecycle Bot — Cloudflare Worker Entry Point
 *
 * This is the top-level orchestrator that runs as a Cloudflare Worker:
 *
 *   1. `scheduled` handler — Cron trigger that polls draw readiness and
 *      advances the draw lifecycle one phase at a time. State is persisted
 *      in KV between invocations.
 *
 *   2. `fetch` handler — Receives Telegram webhook updates for bot commands
 *      (/status, /stats, /draw, /pause, /resume, /health, /config, /help).
 *      Also exposes admin endpoints for webhook setup.
 *
 * Architecture:
 *   - Each cron tick checks on-chain state and advances ONE phase per program
 *   - Draw state is persisted in Cloudflare KV (DRAW_STATE namespace)
 *   - Telegram is used for notifications and command interface
 *   - Config is loaded from Worker env bindings (vars + secrets)
 *   - The bot is stateless between invocations; all state lives in KV + on-chain
 */

import { Connection } from "@solana/web3.js";
import {
  Program,
  AnchorProvider,
  Wallet,
  setProvider,
} from "@coral-xyz/anchor";

import { loadConfig, formatConfigSummary, type BotConfig } from "./config";
import {
  createLogger,
  logError,
  logFatal,
  sendAlert,
  type Logger,
} from "./logger";
import {
  executeMainDrawLifecycle,
  executeQPDrawLifecycle,
  isMainDrawReady,
  isQPDrawReady,
  type DrawState,
} from "./draw-executor";
import {
  handleTelegramWebhook,
  setTelegramWebhook,
  deleteTelegramWebhook,
  notifyDrawComplete,
  notifyDrawError,
} from "./telegram";
import type { Env, PersistedBotStats, PersistedDrawState } from "./env";
import { KV_KEYS } from "./env";

// ---------------------------------------------------------------------------
// IDL Imports — Embedded at build time by wrangler's bundler
// ---------------------------------------------------------------------------
// The IDL JSON files are generated by `anchor build` and must be copied into
// bot/src/idl/ before deploying the Worker. Wrangler bundles them at build time.
//
// Setup:
//   1. Run `anchor build` from the project root
//   2. Copy the generated IDLs:
//        mkdir -p bot/src/idl
//        cp target/idl/mazelprotocol.json bot/src/idl/
//        cp target/idl/quickpick.json bot/src/idl/
//   3. Deploy: npm run deploy
//
// If the IDL files are missing, wrangler will fail at build time with a
// clear error pointing to these imports.

// @ts-expect-error — JSON import resolved by wrangler bundler
import mainIDL from "./idl/mazelprotocol.json";
import qpIDL from "./idl/quickpick.json";

// ---------------------------------------------------------------------------
// Program setup helpers
// ---------------------------------------------------------------------------

/**
 * Create Anchor programs for both the main lottery and Quick Pick Express.
 * Called on every invocation since Workers are stateless.
 */
function createPrograms(
  config: BotConfig,
  connection: Connection,
): {
  mainProgram: Program<any>;
  qpProgram: Program<any>;
  provider: AnchorProvider;
} {
  const wallet = new Wallet(config.authorityKeypair);
  const provider = new AnchorProvider(connection, wallet, {
    commitment: config.commitment,
    preflightCommitment: config.commitment,
  });
  setProvider(provider);

  const mainProgram = new Program(mainIDL as any, provider);
  const qpProgram = new Program(qpIDL as any, provider);

  return { mainProgram, qpProgram, provider };
}

// ---------------------------------------------------------------------------
// Stats helpers
// ---------------------------------------------------------------------------

async function loadStats(kv: KVNamespace): Promise<PersistedBotStats> {
  const raw = await kv.get(KV_KEYS.BOT_STATS);
  if (raw) {
    return JSON.parse(raw);
  }
  return {
    startTime: new Date().toISOString(),
    pollCount: 0,
    mainDrawsCompleted: 0,
    mainDrawsFailed: 0,
    qpDrawsCompleted: 0,
    qpDrawsFailed: 0,
    lastMainDrawId: null,
    lastMainDrawPhase: null,
    lastQPDrawId: null,
    lastQPDrawPhase: null,
    consecutiveErrors: 0,
  };
}

async function saveStats(
  kv: KVNamespace,
  stats: PersistedBotStats,
): Promise<void> {
  await kv.put(KV_KEYS.BOT_STATS, JSON.stringify(stats));
}

// ---------------------------------------------------------------------------
// Draw state persistence
// ---------------------------------------------------------------------------

async function _loadDrawState(
  kv: KVNamespace,
  key: string,
): Promise<PersistedDrawState | null> {
  const raw = await kv.get(key);
  if (!raw) return null;
  return JSON.parse(raw);
}

async function saveDrawState(
  kv: KVNamespace,
  key: string,
  state: PersistedDrawState,
): Promise<void> {
  await kv.put(key, JSON.stringify(state));
}

function drawStateToKV(state: DrawState): PersistedDrawState {
  return {
    program: state.program,
    drawId: state.drawId.toString(),
    phase: state.phase as PersistedDrawState["phase"],
    commitSlot: state.commitSlot,
    commitTimestamp: state.commitTimestamp,
    randomnessAccount: state.randomnessAccount?.toBase58(),
    winningNumbers: state.winningNumbers,
    errorCount: state.errorCount,
    lastError: state.lastError,
    lastAttemptTimestamp: state.lastAttemptTimestamp,
    indexerResult: state.indexerResult
      ? {
          winnerCounts: state.indexerResult.winnerCounts as unknown as Record<
            string,
            number
          >,
          totalTicketsScanned: state.indexerResult.totalTicketsScanned,
          verificationHash: Buffer.from(
            state.indexerResult.verificationHash,
          ).toString("hex"),
          nonce: state.indexerResult.nonce.toString(),
        }
      : undefined,
  };
}

// ---------------------------------------------------------------------------
// Scheduled Handler — Cron trigger for draw polling
// ---------------------------------------------------------------------------

async function handleScheduled(
  _event: ScheduledController,
  env: Env,
  ctx: ExecutionContext,
): Promise<void> {
  let config: BotConfig;
  let logger: Logger;

  try {
    config = loadConfig(env);
  } catch (err: unknown) {
    const msg = err instanceof Error ? err.message : String(err);
    console.error(`❌ Failed to load configuration: ${msg}`);
    return;
  }

  logger = createLogger({
    level: (config.logLevel as any) || "info",
    telegramBotToken: config.telegramBotToken,
    telegramChatId: config.telegramChatId,
  });

  // Check if bot is paused
  const isPaused = await env.DRAW_STATE.get(KV_KEYS.BOT_PAUSED);
  if (isPaused === "true") {
    logger.debug("Bot is paused — skipping cron tick");
    return;
  }

  // Create connection and programs
  const connection = new Connection(config.rpcUrl, {
    commitment: config.commitment,
    confirmTransactionInitialTimeout: config.txConfirmTimeoutMs,
  });

  let mainProgram: Program<any>;
  let qpProgram: Program<any>;

  try {
    const programs = createPrograms(config, connection);
    mainProgram = programs.mainProgram;
    qpProgram = programs.qpProgram;
  } catch (err: unknown) {
    const msg = err instanceof Error ? err.message : String(err);
    logFatal(logger, `Failed to load programs: ${msg}`, { error: msg });
    return;
  }

  // Load stats
  const stats = await loadStats(env.DRAW_STATE);
  stats.pollCount++;

  logger.debug({ pollCount: stats.pollCount }, `Cron tick #${stats.pollCount}`);

  // ---- Main Lottery ----
  if (config.mode === "both" || config.mode === "main-only") {
    ctx.waitUntil(
      processMainDraw(
        connection,
        mainProgram,
        config,
        env,
        logger,
        stats,
      ).catch((err) => {
        const msg = err instanceof Error ? err.message : String(err);
        logError(
          logger,
          `[main] Unhandled error in cron tick: ${msg}`,
          { error: msg },
          true,
        );
        stats.mainDrawsFailed++;
        stats.consecutiveErrors++;
      }),
    );
  }

  // ---- Quick Pick Express ----
  if (config.mode === "both" || config.mode === "qp-only") {
    ctx.waitUntil(
      processQPDraw(
        connection,
        mainProgram,
        qpProgram,
        config,
        env,
        logger,
        stats,
      ).catch((err) => {
        const msg = err instanceof Error ? err.message : String(err);
        logError(
          logger,
          `[quickpick] Unhandled error in cron tick: ${msg}`,
          { error: msg },
          true,
        );
        stats.qpDrawsFailed++;
        stats.consecutiveErrors++;
      }),
    );
  }

  // Save stats (we use waitUntil so the response isn't blocked)
  ctx.waitUntil(saveStats(env.DRAW_STATE, stats));
}

// ---------------------------------------------------------------------------
// Draw Processing — Main Lottery
// ---------------------------------------------------------------------------

async function processMainDraw(
  connection: Connection,
  mainProgram: Program<any>,
  config: BotConfig,
  env: Env,
  logger: Logger,
  stats: PersistedBotStats,
): Promise<void> {
  try {
    const readiness = await isMainDrawReady(mainProgram, config, logger);

    if (!readiness.ready) {
      logger.debug(
        {
          drawId: readiness.drawId ? Number(readiness.drawId) : null,
          reason: readiness.reason,
        },
        `[main] Not ready: ${readiness.reason}`,
      );
      return;
    }

    logger.info(
      {
        drawId: readiness.drawId ? Number(readiness.drawId) : null,
        reason: readiness.reason,
      },
      `[main] Draw ready: ${readiness.reason}`,
    );

    if (config.dryRun) {
      logger.warn("[main] DRY RUN — skipping draw execution");
      return;
    }

    // Execute the full draw lifecycle
    const result: DrawState = await executeMainDrawLifecycle(
      connection,
      mainProgram,
      config,
      logger,
    );

    stats.lastMainDrawId = result.drawId.toString();
    stats.lastMainDrawPhase = result.phase;

    // Persist state for status queries
    await saveDrawState(
      env.DRAW_STATE,
      KV_KEYS.MAIN_DRAW_STATE,
      drawStateToKV(result),
    );

    if (result.phase === "finalized") {
      stats.mainDrawsCompleted++;
      stats.consecutiveErrors = 0;

      logger.info(
        {
          drawId: Number(result.drawId),
          totalCompleted: stats.mainDrawsCompleted,
        },
        `[main] ✅ Draw #${result.drawId} completed successfully (total: ${stats.mainDrawsCompleted})`,
      );

      // Telegram notification
      if (result.indexerResult) {
        await notifyDrawComplete(
          "main",
          result.drawId,
          result.winningNumbers ?? [],
          result.indexerResult.totalTicketsScanned,
          result.indexerResult.winnerCounts as unknown as Record<
            string,
            number
          >,
        );
      } else {
        await sendAlert(
          "warn",
          `[main] Draw #${result.drawId} completed successfully`,
          {
            drawId: Number(result.drawId),
            totalCompleted: stats.mainDrawsCompleted,
          },
        );
      }
    } else if (result.phase === "error") {
      stats.mainDrawsFailed++;
      stats.consecutiveErrors++;

      logError(
        logger,
        `[main] Draw #${result.drawId} failed: ${result.lastError}`,
        {
          drawId: Number(result.drawId),
          phase: result.phase,
          error: result.lastError,
          errorCount: result.errorCount,
          consecutiveErrors: stats.consecutiveErrors,
        },
        true,
      );

      await notifyDrawError(
        "main",
        result.drawId,
        result.phase,
        result.lastError ?? "Unknown error",
      );

      if (stats.consecutiveErrors >= 5) {
        logFatal(
          logger,
          `[main] ${stats.consecutiveErrors} consecutive draw failures — possible systemic issue`,
          {
            consecutiveErrors: stats.consecutiveErrors,
            lastError: result.lastError,
          },
        );
      }
    }
  } catch (err: unknown) {
    stats.mainDrawsFailed++;
    stats.consecutiveErrors++;
    const msg = err instanceof Error ? err.message : String(err);
    logError(
      logger,
      `[main] Unhandled error in draw lifecycle: ${msg}`,
      { error: msg, stack: err instanceof Error ? err.stack : undefined },
      true,
    );
  }
}

// ---------------------------------------------------------------------------
// Draw Processing — Quick Pick Express
// ---------------------------------------------------------------------------

async function processQPDraw(
  connection: Connection,
  mainProgram: Program<any>,
  qpProgram: Program<any>,
  config: BotConfig,
  env: Env,
  logger: Logger,
  stats: PersistedBotStats,
): Promise<void> {
  try {
    const readiness = await isQPDrawReady(qpProgram, config, logger);

    if (!readiness.ready) {
      logger.debug(
        {
          drawId: readiness.drawId ? Number(readiness.drawId) : null,
          reason: readiness.reason,
        },
        `[quickpick] Not ready: ${readiness.reason}`,
      );
      return;
    }

    logger.info(
      {
        drawId: readiness.drawId ? Number(readiness.drawId) : null,
        reason: readiness.reason,
      },
      `[quickpick] Draw ready: ${readiness.reason}`,
    );

    if (config.dryRun) {
      logger.warn("[quickpick] DRY RUN — skipping draw execution");
      return;
    }

    // Execute the full draw lifecycle
    const result: DrawState = await executeQPDrawLifecycle(
      connection,
      mainProgram,
      qpProgram,
      config,
      logger,
    );

    stats.lastQPDrawId = result.drawId.toString();
    stats.lastQPDrawPhase = result.phase;

    // Persist state for status queries
    await saveDrawState(
      env.DRAW_STATE,
      KV_KEYS.QP_DRAW_STATE,
      drawStateToKV(result),
    );

    if (result.phase === "finalized") {
      stats.qpDrawsCompleted++;
      stats.consecutiveErrors = 0;

      logger.info(
        {
          drawId: Number(result.drawId),
          totalCompleted: stats.qpDrawsCompleted,
        },
        `[quickpick] ✅ Draw #${result.drawId} completed successfully (total: ${stats.qpDrawsCompleted})`,
      );

      if (result.indexerResult) {
        await notifyDrawComplete(
          "quickpick",
          result.drawId,
          result.winningNumbers ?? [],
          result.indexerResult.totalTicketsScanned,
          result.indexerResult.winnerCounts as unknown as Record<
            string,
            number
          >,
        );
      } else {
        await sendAlert(
          "warn",
          `[quickpick] Draw #${result.drawId} completed successfully`,
          {
            drawId: Number(result.drawId),
            totalCompleted: stats.qpDrawsCompleted,
          },
        );
      }
    } else if (result.phase === "error") {
      stats.qpDrawsFailed++;
      stats.consecutiveErrors++;

      logError(
        logger,
        `[quickpick] Draw #${result.drawId} failed: ${result.lastError}`,
        {
          drawId: Number(result.drawId),
          phase: result.phase,
          error: result.lastError,
          errorCount: result.errorCount,
          consecutiveErrors: stats.consecutiveErrors,
        },
        true,
      );

      await notifyDrawError(
        "quickpick",
        result.drawId,
        result.phase,
        result.lastError ?? "Unknown error",
      );

      if (stats.consecutiveErrors >= 5) {
        logFatal(
          logger,
          `[quickpick] ${stats.consecutiveErrors} consecutive draw failures — possible systemic issue`,
          {
            consecutiveErrors: stats.consecutiveErrors,
            lastError: result.lastError,
          },
        );
      }
    }
  } catch (err: unknown) {
    stats.qpDrawsFailed++;
    stats.consecutiveErrors++;
    const msg = err instanceof Error ? err.message : String(err);
    logError(
      logger,
      `[quickpick] Unhandled error in draw lifecycle: ${msg}`,
      { error: msg, stack: err instanceof Error ? err.stack : undefined },
      true,
    );
  }
}

// ---------------------------------------------------------------------------
// Fetch Handler — Telegram Webhook + Admin Endpoints
// ---------------------------------------------------------------------------

async function handleFetch(
  request: Request,
  env: Env,
  _ctx: ExecutionContext,
): Promise<Response> {
  const url = new URL(request.url);

  // Health check endpoint
  if (url.pathname === "/" || url.pathname === "/health") {
    return new Response(
      JSON.stringify({
        status: "ok",
        service: "mazelprotocol-draw-bot",
        timestamp: new Date().toISOString(),
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" },
      },
    );
  }

  // Telegram webhook endpoint
  if (url.pathname === "/telegram" && request.method === "POST") {
    let config: BotConfig;
    try {
      config = loadConfig(env);
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      console.error(`Failed to load config for webhook: ${msg}`);
      return new Response("OK", { status: 200 });
    }

    const logger = createLogger({
      level: (config.logLevel as any) || "info",
      telegramBotToken: config.telegramBotToken,
      telegramChatId: config.telegramChatId,
    });

    const connection = new Connection(config.rpcUrl, {
      commitment: config.commitment,
      confirmTransactionInitialTimeout: config.txConfirmTimeoutMs,
    });

    let mainProgram: Program<any>;
    let qpProgram: Program<any>;

    try {
      const programs = createPrograms(config, connection);
      mainProgram = programs.mainProgram;
      qpProgram = programs.qpProgram;
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to load programs for webhook: ${msg}`);
      return new Response("OK", { status: 200 });
    }

    return handleTelegramWebhook(
      request,
      env,
      config,
      logger,
      connection,
      mainProgram,
      qpProgram,
    );
  }

  // Admin: Set Telegram webhook
  if (url.pathname === "/admin/set-webhook" && request.method === "POST") {
    let config: BotConfig;
    try {
      config = loadConfig(env);
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      return new Response(JSON.stringify({ error: msg }), {
        status: 500,
        headers: { "Content-Type": "application/json" },
      });
    }

    // Derive the webhook URL from the current request
    const workerUrl = `${url.protocol}//${url.host}/telegram`;
    const result = await setTelegramWebhook(config.telegramBotToken, workerUrl);

    return new Response(JSON.stringify({ webhookUrl: workerUrl, ...result }), {
      status: result.ok ? 200 : 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // Admin: Delete Telegram webhook
  if (url.pathname === "/admin/delete-webhook" && request.method === "POST") {
    let config: BotConfig;
    try {
      config = loadConfig(env);
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      return new Response(JSON.stringify({ error: msg }), {
        status: 500,
        headers: { "Content-Type": "application/json" },
      });
    }

    const result = await deleteTelegramWebhook(config.telegramBotToken);

    return new Response(JSON.stringify(result), {
      status: result.ok ? 200 : 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // Admin: Get bot stats
  if (url.pathname === "/admin/stats" && request.method === "GET") {
    const stats = await loadStats(env.DRAW_STATE);
    return new Response(JSON.stringify(stats, null, 2), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  }

  // Admin: Pause/Resume
  if (url.pathname === "/admin/pause" && request.method === "POST") {
    await env.DRAW_STATE.put(KV_KEYS.BOT_PAUSED, "true");
    return new Response(JSON.stringify({ paused: true }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  }

  if (url.pathname === "/admin/resume" && request.method === "POST") {
    await env.DRAW_STATE.put(KV_KEYS.BOT_PAUSED, "false");
    return new Response(JSON.stringify({ paused: false }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  }

  // Admin: Get current config summary (no secrets)
  if (url.pathname === "/admin/config" && request.method === "GET") {
    try {
      const config = loadConfig(env);
      return new Response(formatConfigSummary(config), {
        status: 200,
        headers: { "Content-Type": "text/plain" },
      });
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      return new Response(JSON.stringify({ error: msg }), {
        status: 500,
        headers: { "Content-Type": "application/json" },
      });
    }
  }

  // 404 for everything else
  return new Response(
    JSON.stringify({
      error: "Not found",
      availableEndpoints: [
        "GET  /                     — Health check",
        "POST /telegram             — Telegram webhook",
        "POST /admin/set-webhook    — Set Telegram webhook URL",
        "POST /admin/delete-webhook — Delete Telegram webhook",
        "GET  /admin/stats          — Bot statistics",
        "POST /admin/pause          — Pause the bot",
        "POST /admin/resume         — Resume the bot",
        "GET  /admin/config         — Configuration summary",
      ],
    }),
    {
      status: 404,
      headers: { "Content-Type": "application/json" },
    },
  );
}

// ---------------------------------------------------------------------------
// Worker Export
// ---------------------------------------------------------------------------

export default {
  fetch: handleFetch,
  scheduled: handleScheduled,
} satisfies ExportedHandler<Env>;
